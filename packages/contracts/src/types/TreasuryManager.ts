/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type TradeStruct = {
  tradeType: PromiseOrValue<BigNumberish>;
  sellToken: PromiseOrValue<string>;
  buyToken: PromiseOrValue<string>;
  amount: PromiseOrValue<BigNumberish>;
  limit: PromiseOrValue<BigNumberish>;
  deadline: PromiseOrValue<BigNumberish>;
  exchangeData: PromiseOrValue<BytesLike>;
};

export type TradeStructOutput = [
  number,
  string,
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  string
] & {
  tradeType: number;
  sellToken: string;
  buyToken: string;
  amount: BigNumber;
  limit: BigNumber;
  deadline: BigNumber;
  exchangeData: string;
};

export declare namespace IExchangeV3 {
  export type OrderStruct = {
    makerAddress: PromiseOrValue<string>;
    takerAddress: PromiseOrValue<string>;
    feeRecipientAddress: PromiseOrValue<string>;
    senderAddress: PromiseOrValue<string>;
    makerAssetAmount: PromiseOrValue<BigNumberish>;
    takerAssetAmount: PromiseOrValue<BigNumberish>;
    makerFee: PromiseOrValue<BigNumberish>;
    takerFee: PromiseOrValue<BigNumberish>;
    expirationTimeSeconds: PromiseOrValue<BigNumberish>;
    salt: PromiseOrValue<BigNumberish>;
    makerAssetData: PromiseOrValue<BytesLike>;
    takerAssetData: PromiseOrValue<BytesLike>;
    makerFeeAssetData: PromiseOrValue<BytesLike>;
    takerFeeAssetData: PromiseOrValue<BytesLike>;
  };

  export type OrderStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    string,
    string
  ] & {
    makerAddress: string;
    takerAddress: string;
    feeRecipientAddress: string;
    senderAddress: string;
    makerAssetAmount: BigNumber;
    takerAssetAmount: BigNumber;
    makerFee: BigNumber;
    takerFee: BigNumber;
    expirationTimeSeconds: BigNumber;
    salt: BigNumber;
    makerAssetData: string;
    takerAssetData: string;
    makerFeeAssetData: string;
    takerFeeAssetData: string;
  };
}

export declare namespace IStrategyVault {
  export type TradeParamsStruct = {
    dexId: PromiseOrValue<BigNumberish>;
    tradeType: PromiseOrValue<BigNumberish>;
    oracleSlippagePercentOrLimit: PromiseOrValue<BigNumberish>;
    exchangeData: PromiseOrValue<BytesLike>;
  };

  export type TradeParamsStructOutput = [number, number, BigNumber, string] & {
    dexId: number;
    tradeType: number;
    oracleSlippagePercentOrLimit: BigNumber;
    exchangeData: string;
  };

  export type SingleSidedRewardTradeParamsStruct = {
    sellToken: PromiseOrValue<string>;
    buyToken: PromiseOrValue<string>;
    amount: PromiseOrValue<BigNumberish>;
    tradeParams: IStrategyVault.TradeParamsStruct;
  };

  export type SingleSidedRewardTradeParamsStructOutput = [
    string,
    string,
    BigNumber,
    IStrategyVault.TradeParamsStructOutput
  ] & {
    sellToken: string;
    buyToken: string;
    amount: BigNumber;
    tradeParams: IStrategyVault.TradeParamsStructOutput;
  };
}

export interface TreasuryManagerInterface extends utils.Interface {
  functions: {
    "ASSET_PROXY()": FunctionFragment;
    "BALANCER_POOL_TOKEN()": FunctionFragment;
    "BALANCER_VAULT()": FunctionFragment;
    "EXCHANGE()": FunctionFragment;
    "MAXIMUM_COOL_DOWN_PERIOD_SECONDS()": FunctionFragment;
    "MAX_ORACLE_WINDOW_SIZE()": FunctionFragment;
    "NOTE()": FunctionFragment;
    "NOTE_ETH_POOL_ID()": FunctionFragment;
    "NOTE_INDEX()": FunctionFragment;
    "NOTIONAL()": FunctionFragment;
    "TRADING_MODULE()": FunctionFragment;
    "WETH()": FunctionFragment;
    "WETH_INDEX()": FunctionFragment;
    "_getNOTESpotPrice()": FunctionFragment;
    "approveBalancer()": FunctionFragment;
    "approveToken(address,uint256)": FunctionFragment;
    "cancelOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes))": FunctionFragment;
    "claimBAL()": FunctionFragment;
    "claimOwnership()": FunctionFragment;
    "claimVaultRewardTokens(address)": FunctionFragment;
    "coolDownTimeInSeconds()": FunctionFragment;
    "executeTrade((uint8,address,address,uint256,uint256,uint256,bytes),uint8)": FunctionFragment;
    "harvestAssetsFromNotional(uint16[])": FunctionFragment;
    "harvestCOMPFromNotional(address[])": FunctionFragment;
    "initialize(address,address,uint32)": FunctionFragment;
    "investWETHAndNOTE(uint256,uint256,uint256)": FunctionFragment;
    "isValidSignature(bytes,bytes)": FunctionFragment;
    "lastInvestTimestamp()": FunctionFragment;
    "manager()": FunctionFragment;
    "notePurchaseLimit()": FunctionFragment;
    "owner()": FunctionFragment;
    "pendingOwner()": FunctionFragment;
    "priceOracleWindowInSeconds()": FunctionFragment;
    "priceOracles(address)": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "reinvestVaultReward(address,(address,address,uint256,(uint16,uint8,uint256,bytes))[],uint256)": FunctionFragment;
    "sNOTE()": FunctionFragment;
    "setCoolDownTime(uint32)": FunctionFragment;
    "setManager(address)": FunctionFragment;
    "setNOTEPurchaseLimit(uint256)": FunctionFragment;
    "setPriceOracle(address,address)": FunctionFragment;
    "setPriceOracleWindow(uint32)": FunctionFragment;
    "setSlippageLimit(address,uint256)": FunctionFragment;
    "slippageLimits(address)": FunctionFragment;
    "transferOwnership(address,bool,bool)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
    "withdraw(address,uint256)": FunctionFragment;
    "wrapToWETH()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "ASSET_PROXY"
      | "BALANCER_POOL_TOKEN"
      | "BALANCER_VAULT"
      | "EXCHANGE"
      | "MAXIMUM_COOL_DOWN_PERIOD_SECONDS"
      | "MAX_ORACLE_WINDOW_SIZE"
      | "NOTE"
      | "NOTE_ETH_POOL_ID"
      | "NOTE_INDEX"
      | "NOTIONAL"
      | "TRADING_MODULE"
      | "WETH"
      | "WETH_INDEX"
      | "_getNOTESpotPrice"
      | "approveBalancer"
      | "approveToken"
      | "cancelOrder"
      | "claimBAL"
      | "claimOwnership"
      | "claimVaultRewardTokens"
      | "coolDownTimeInSeconds"
      | "executeTrade"
      | "harvestAssetsFromNotional"
      | "harvestCOMPFromNotional"
      | "initialize"
      | "investWETHAndNOTE"
      | "isValidSignature"
      | "lastInvestTimestamp"
      | "manager"
      | "notePurchaseLimit"
      | "owner"
      | "pendingOwner"
      | "priceOracleWindowInSeconds"
      | "priceOracles"
      | "proxiableUUID"
      | "reinvestVaultReward"
      | "sNOTE"
      | "setCoolDownTime"
      | "setManager"
      | "setNOTEPurchaseLimit"
      | "setPriceOracle"
      | "setPriceOracleWindow"
      | "setSlippageLimit"
      | "slippageLimits"
      | "transferOwnership"
      | "upgradeTo"
      | "upgradeToAndCall"
      | "withdraw"
      | "wrapToWETH"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "ASSET_PROXY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BALANCER_POOL_TOKEN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BALANCER_VAULT",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "EXCHANGE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MAXIMUM_COOL_DOWN_PERIOD_SECONDS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_ORACLE_WINDOW_SIZE",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NOTE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "NOTE_ETH_POOL_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "NOTE_INDEX",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NOTIONAL", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "TRADING_MODULE",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "WETH", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "WETH_INDEX",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_getNOTESpotPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approveBalancer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approveToken",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [IExchangeV3.OrderStruct]
  ): string;
  encodeFunctionData(functionFragment: "claimBAL", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "claimOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimVaultRewardTokens",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "coolDownTimeInSeconds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeTrade",
    values: [TradeStruct, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "harvestAssetsFromNotional",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "harvestCOMPFromNotional",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "investWETHAndNOTE",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidSignature",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "lastInvestTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "manager", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "notePurchaseLimit",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracleWindowInSeconds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracles",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reinvestVaultReward",
    values: [
      PromiseOrValue<string>,
      IStrategyVault.SingleSidedRewardTradeParamsStruct[],
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "sNOTE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setCoolDownTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setNOTEPurchaseLimit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracle",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracleWindow",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSlippageLimit",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "slippageLimits",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "wrapToWETH",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "ASSET_PROXY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BALANCER_POOL_TOKEN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BALANCER_VAULT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "EXCHANGE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MAXIMUM_COOL_DOWN_PERIOD_SECONDS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_ORACLE_WINDOW_SIZE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NOTE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "NOTE_ETH_POOL_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NOTE_INDEX", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "NOTIONAL", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "TRADING_MODULE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "WETH", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "WETH_INDEX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_getNOTESpotPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveBalancer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claimBAL", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimVaultRewardTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "coolDownTimeInSeconds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "harvestAssetsFromNotional",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "harvestCOMPFromNotional",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "investWETHAndNOTE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastInvestTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "manager", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "notePurchaseLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracleWindowInSeconds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reinvestVaultReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sNOTE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setCoolDownTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setManager", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setNOTEPurchaseLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracleWindow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSlippageLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "slippageLimits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "wrapToWETH", data: BytesLike): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "AssetsHarvested(uint16[],uint256[])": EventFragment;
    "AssetsInvested(uint256,uint256)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "COMPHarvested(address[],uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "InvestmentCoolDownUpdated(uint256)": EventFragment;
    "ManagementTransferred(address,address)": EventFragment;
    "NOTEPurchaseLimitUpdated(uint256)": EventFragment;
    "OrderCancelled(uint8,bytes32,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PriceOracleUpdated(address,address)": EventFragment;
    "PriceOracleWindowUpdated(uint256)": EventFragment;
    "SlippageLimitUpdated(address,uint256)": EventFragment;
    "TradeExecuted(address,address,uint256,uint256)": EventFragment;
    "Upgraded(address)": EventFragment;
    "VaultRewardReinvested(address,address,uint256,uint256)": EventFragment;
    "VaultRewardTokensClaimed(address,address[],uint256[])": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AssetsHarvested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AssetsInvested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "COMPHarvested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "InvestmentCoolDownUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ManagementTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NOTEPurchaseLimitUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PriceOracleUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PriceOracleWindowUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SlippageLimitUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TradeExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultRewardReinvested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultRewardTokensClaimed"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface AssetsHarvestedEventObject {
  currencies: number[];
  amounts: BigNumber[];
}
export type AssetsHarvestedEvent = TypedEvent<
  [number[], BigNumber[]],
  AssetsHarvestedEventObject
>;

export type AssetsHarvestedEventFilter = TypedEventFilter<AssetsHarvestedEvent>;

export interface AssetsInvestedEventObject {
  wethAmount: BigNumber;
  noteAmount: BigNumber;
}
export type AssetsInvestedEvent = TypedEvent<
  [BigNumber, BigNumber],
  AssetsInvestedEventObject
>;

export type AssetsInvestedEventFilter = TypedEventFilter<AssetsInvestedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface COMPHarvestedEventObject {
  ctokens: string[];
  amount: BigNumber;
}
export type COMPHarvestedEvent = TypedEvent<
  [string[], BigNumber],
  COMPHarvestedEventObject
>;

export type COMPHarvestedEventFilter = TypedEventFilter<COMPHarvestedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface InvestmentCoolDownUpdatedEventObject {
  newCoolDownTimeSeconds: BigNumber;
}
export type InvestmentCoolDownUpdatedEvent = TypedEvent<
  [BigNumber],
  InvestmentCoolDownUpdatedEventObject
>;

export type InvestmentCoolDownUpdatedEventFilter =
  TypedEventFilter<InvestmentCoolDownUpdatedEvent>;

export interface ManagementTransferredEventObject {
  prevManager: string;
  newManager: string;
}
export type ManagementTransferredEvent = TypedEvent<
  [string, string],
  ManagementTransferredEventObject
>;

export type ManagementTransferredEventFilter =
  TypedEventFilter<ManagementTransferredEvent>;

export interface NOTEPurchaseLimitUpdatedEventObject {
  purchaseLimit: BigNumber;
}
export type NOTEPurchaseLimitUpdatedEvent = TypedEvent<
  [BigNumber],
  NOTEPurchaseLimitUpdatedEventObject
>;

export type NOTEPurchaseLimitUpdatedEventFilter =
  TypedEventFilter<NOTEPurchaseLimitUpdatedEvent>;

export interface OrderCancelledEventObject {
  orderStatus: number;
  orderHash: string;
  orderTakerAssetFilledAmount: BigNumber;
}
export type OrderCancelledEvent = TypedEvent<
  [number, string, BigNumber],
  OrderCancelledEventObject
>;

export type OrderCancelledEventFilter = TypedEventFilter<OrderCancelledEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PriceOracleUpdatedEventObject {
  tokenAddress: string;
  oracleAddress: string;
}
export type PriceOracleUpdatedEvent = TypedEvent<
  [string, string],
  PriceOracleUpdatedEventObject
>;

export type PriceOracleUpdatedEventFilter =
  TypedEventFilter<PriceOracleUpdatedEvent>;

export interface PriceOracleWindowUpdatedEventObject {
  _priceOracleWindowInSeconds: BigNumber;
}
export type PriceOracleWindowUpdatedEvent = TypedEvent<
  [BigNumber],
  PriceOracleWindowUpdatedEventObject
>;

export type PriceOracleWindowUpdatedEventFilter =
  TypedEventFilter<PriceOracleWindowUpdatedEvent>;

export interface SlippageLimitUpdatedEventObject {
  tokenAddress: string;
  slippageLimit: BigNumber;
}
export type SlippageLimitUpdatedEvent = TypedEvent<
  [string, BigNumber],
  SlippageLimitUpdatedEventObject
>;

export type SlippageLimitUpdatedEventFilter =
  TypedEventFilter<SlippageLimitUpdatedEvent>;

export interface TradeExecutedEventObject {
  sellToken: string;
  buyToken: string;
  sellAmount: BigNumber;
  buyAmount: BigNumber;
}
export type TradeExecutedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  TradeExecutedEventObject
>;

export type TradeExecutedEventFilter = TypedEventFilter<TradeExecutedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface VaultRewardReinvestedEventObject {
  vault: string;
  rewardToken: string;
  amountSold: BigNumber;
  poolClaimAmount: BigNumber;
}
export type VaultRewardReinvestedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  VaultRewardReinvestedEventObject
>;

export type VaultRewardReinvestedEventFilter =
  TypedEventFilter<VaultRewardReinvestedEvent>;

export interface VaultRewardTokensClaimedEventObject {
  vault: string;
  rewardTokens: string[];
  claimedBalances: BigNumber[];
}
export type VaultRewardTokensClaimedEvent = TypedEvent<
  [string, string[], BigNumber[]],
  VaultRewardTokensClaimedEventObject
>;

export type VaultRewardTokensClaimedEventFilter =
  TypedEventFilter<VaultRewardTokensClaimedEvent>;

export interface TreasuryManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TreasuryManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<[string]>;

    BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<[string]>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<[string]>;

    EXCHANGE(overrides?: CallOverrides): Promise<[string]>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<[number]>;

    MAX_ORACLE_WINDOW_SIZE(overrides?: CallOverrides): Promise<[number]>;

    NOTE(overrides?: CallOverrides): Promise<[string]>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<[string]>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<[BigNumber]>;

    NOTIONAL(overrides?: CallOverrides): Promise<[string]>;

    TRADING_MODULE(overrides?: CallOverrides): Promise<[string]>;

    WETH(overrides?: CallOverrides): Promise<[string]>;

    WETH_INDEX(overrides?: CallOverrides): Promise<[BigNumber]>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    approveBalancer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimBAL(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimVaultRewardTokens(
      vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    coolDownTimeInSeconds(overrides?: CallOverrides): Promise<[number]>;

    executeTrade(
      trade: TradeStruct,
      dexId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    lastInvestTimestamp(overrides?: CallOverrides): Promise<[number]>;

    manager(overrides?: CallOverrides): Promise<[string]>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    priceOracleWindowInSeconds(overrides?: CallOverrides): Promise<[number]>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    reinvestVaultReward(
      vault: PromiseOrValue<string>,
      trades: IStrategyVault.SingleSidedRewardTradeParamsStruct[],
      minPoolClaim: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    sNOTE(overrides?: CallOverrides): Promise<[string]>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPriceOracleWindow(
      _priceOracleWindowInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    wrapToWETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  ASSET_PROXY(overrides?: CallOverrides): Promise<string>;

  BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<string>;

  BALANCER_VAULT(overrides?: CallOverrides): Promise<string>;

  EXCHANGE(overrides?: CallOverrides): Promise<string>;

  MAXIMUM_COOL_DOWN_PERIOD_SECONDS(overrides?: CallOverrides): Promise<number>;

  MAX_ORACLE_WINDOW_SIZE(overrides?: CallOverrides): Promise<number>;

  NOTE(overrides?: CallOverrides): Promise<string>;

  NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<string>;

  NOTE_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

  NOTIONAL(overrides?: CallOverrides): Promise<string>;

  TRADING_MODULE(overrides?: CallOverrides): Promise<string>;

  WETH(overrides?: CallOverrides): Promise<string>;

  WETH_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

  _getNOTESpotPrice(overrides?: CallOverrides): Promise<BigNumber>;

  approveBalancer(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approveToken(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelOrder(
    order: IExchangeV3.OrderStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimBAL(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimVaultRewardTokens(
    vault: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  coolDownTimeInSeconds(overrides?: CallOverrides): Promise<number>;

  executeTrade(
    trade: TradeStruct,
    dexId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  harvestAssetsFromNotional(
    currencies: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  harvestCOMPFromNotional(
    ctokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _owner: PromiseOrValue<string>,
    _manager: PromiseOrValue<string>,
    _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  investWETHAndNOTE(
    wethAmount: PromiseOrValue<BigNumberish>,
    noteAmount: PromiseOrValue<BigNumberish>,
    minBPT: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isValidSignature(
    data: PromiseOrValue<BytesLike>,
    signature: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  lastInvestTimestamp(overrides?: CallOverrides): Promise<number>;

  manager(overrides?: CallOverrides): Promise<string>;

  notePurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  priceOracleWindowInSeconds(overrides?: CallOverrides): Promise<number>;

  priceOracles(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  reinvestVaultReward(
    vault: PromiseOrValue<string>,
    trades: IStrategyVault.SingleSidedRewardTradeParamsStruct[],
    minPoolClaim: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  sNOTE(overrides?: CallOverrides): Promise<string>;

  setCoolDownTime(
    _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setManager(
    newManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNOTEPurchaseLimit(
    purchaseLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPriceOracle(
    tokenAddress: PromiseOrValue<string>,
    oracleAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPriceOracleWindow(
    _priceOracleWindowInSeconds: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSlippageLimit(
    tokenAddress: PromiseOrValue<string>,
    slippageLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slippageLimits(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    direct: PromiseOrValue<boolean>,
    renounce: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  wrapToWETH(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<string>;

    BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<string>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<string>;

    EXCHANGE(overrides?: CallOverrides): Promise<string>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<number>;

    MAX_ORACLE_WINDOW_SIZE(overrides?: CallOverrides): Promise<number>;

    NOTE(overrides?: CallOverrides): Promise<string>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<string>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    NOTIONAL(overrides?: CallOverrides): Promise<string>;

    TRADING_MODULE(overrides?: CallOverrides): Promise<string>;

    WETH(overrides?: CallOverrides): Promise<string>;

    WETH_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    approveBalancer(overrides?: CallOverrides): Promise<void>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    claimBAL(overrides?: CallOverrides): Promise<void>;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    claimVaultRewardTokens(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    coolDownTimeInSeconds(overrides?: CallOverrides): Promise<number>;

    executeTrade(
      trade: TradeStruct,
      dexId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        amountSold: BigNumber;
        amountBought: BigNumber;
      }
    >;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    lastInvestTimestamp(overrides?: CallOverrides): Promise<number>;

    manager(overrides?: CallOverrides): Promise<string>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    priceOracleWindowInSeconds(overrides?: CallOverrides): Promise<number>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    reinvestVaultReward(
      vault: PromiseOrValue<string>,
      trades: IStrategyVault.SingleSidedRewardTradeParamsStruct[],
      minPoolClaim: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber] & {
        rewardToken: string;
        amountSold: BigNumber;
        poolClaimAmount: BigNumber;
      }
    >;

    sNOTE(overrides?: CallOverrides): Promise<string>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPriceOracleWindow(
      _priceOracleWindowInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    wrapToWETH(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "AssetsHarvested(uint16[],uint256[])"(
      currencies?: null,
      amounts?: null
    ): AssetsHarvestedEventFilter;
    AssetsHarvested(
      currencies?: null,
      amounts?: null
    ): AssetsHarvestedEventFilter;

    "AssetsInvested(uint256,uint256)"(
      wethAmount?: null,
      noteAmount?: null
    ): AssetsInvestedEventFilter;
    AssetsInvested(
      wethAmount?: null,
      noteAmount?: null
    ): AssetsInvestedEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "COMPHarvested(address[],uint256)"(
      ctokens?: null,
      amount?: null
    ): COMPHarvestedEventFilter;
    COMPHarvested(ctokens?: null, amount?: null): COMPHarvestedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "InvestmentCoolDownUpdated(uint256)"(
      newCoolDownTimeSeconds?: null
    ): InvestmentCoolDownUpdatedEventFilter;
    InvestmentCoolDownUpdated(
      newCoolDownTimeSeconds?: null
    ): InvestmentCoolDownUpdatedEventFilter;

    "ManagementTransferred(address,address)"(
      prevManager?: null,
      newManager?: null
    ): ManagementTransferredEventFilter;
    ManagementTransferred(
      prevManager?: null,
      newManager?: null
    ): ManagementTransferredEventFilter;

    "NOTEPurchaseLimitUpdated(uint256)"(
      purchaseLimit?: null
    ): NOTEPurchaseLimitUpdatedEventFilter;
    NOTEPurchaseLimitUpdated(
      purchaseLimit?: null
    ): NOTEPurchaseLimitUpdatedEventFilter;

    "OrderCancelled(uint8,bytes32,uint256)"(
      orderStatus?: null,
      orderHash?: null,
      orderTakerAssetFilledAmount?: null
    ): OrderCancelledEventFilter;
    OrderCancelled(
      orderStatus?: null,
      orderHash?: null,
      orderTakerAssetFilledAmount?: null
    ): OrderCancelledEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "PriceOracleUpdated(address,address)"(
      tokenAddress?: null,
      oracleAddress?: null
    ): PriceOracleUpdatedEventFilter;
    PriceOracleUpdated(
      tokenAddress?: null,
      oracleAddress?: null
    ): PriceOracleUpdatedEventFilter;

    "PriceOracleWindowUpdated(uint256)"(
      _priceOracleWindowInSeconds?: null
    ): PriceOracleWindowUpdatedEventFilter;
    PriceOracleWindowUpdated(
      _priceOracleWindowInSeconds?: null
    ): PriceOracleWindowUpdatedEventFilter;

    "SlippageLimitUpdated(address,uint256)"(
      tokenAddress?: null,
      slippageLimit?: null
    ): SlippageLimitUpdatedEventFilter;
    SlippageLimitUpdated(
      tokenAddress?: null,
      slippageLimit?: null
    ): SlippageLimitUpdatedEventFilter;

    "TradeExecuted(address,address,uint256,uint256)"(
      sellToken?: PromiseOrValue<string> | null,
      buyToken?: PromiseOrValue<string> | null,
      sellAmount?: null,
      buyAmount?: null
    ): TradeExecutedEventFilter;
    TradeExecuted(
      sellToken?: PromiseOrValue<string> | null,
      buyToken?: PromiseOrValue<string> | null,
      sellAmount?: null,
      buyAmount?: null
    ): TradeExecutedEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;

    "VaultRewardReinvested(address,address,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      rewardToken?: PromiseOrValue<string> | null,
      amountSold?: null,
      poolClaimAmount?: null
    ): VaultRewardReinvestedEventFilter;
    VaultRewardReinvested(
      vault?: PromiseOrValue<string> | null,
      rewardToken?: PromiseOrValue<string> | null,
      amountSold?: null,
      poolClaimAmount?: null
    ): VaultRewardReinvestedEventFilter;

    "VaultRewardTokensClaimed(address,address[],uint256[])"(
      vault?: PromiseOrValue<string> | null,
      rewardTokens?: null,
      claimedBalances?: null
    ): VaultRewardTokensClaimedEventFilter;
    VaultRewardTokensClaimed(
      vault?: PromiseOrValue<string> | null,
      rewardTokens?: null,
      claimedBalances?: null
    ): VaultRewardTokensClaimedEventFilter;
  };

  estimateGas: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<BigNumber>;

    BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<BigNumber>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<BigNumber>;

    EXCHANGE(overrides?: CallOverrides): Promise<BigNumber>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    MAX_ORACLE_WINDOW_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    NOTE(overrides?: CallOverrides): Promise<BigNumber>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<BigNumber>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    NOTIONAL(overrides?: CallOverrides): Promise<BigNumber>;

    TRADING_MODULE(overrides?: CallOverrides): Promise<BigNumber>;

    WETH(overrides?: CallOverrides): Promise<BigNumber>;

    WETH_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    approveBalancer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimBAL(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimVaultRewardTokens(
      vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    coolDownTimeInSeconds(overrides?: CallOverrides): Promise<BigNumber>;

    executeTrade(
      trade: TradeStruct,
      dexId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastInvestTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    manager(overrides?: CallOverrides): Promise<BigNumber>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    priceOracleWindowInSeconds(overrides?: CallOverrides): Promise<BigNumber>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    reinvestVaultReward(
      vault: PromiseOrValue<string>,
      trades: IStrategyVault.SingleSidedRewardTradeParamsStruct[],
      minPoolClaim: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    sNOTE(overrides?: CallOverrides): Promise<BigNumber>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPriceOracleWindow(
      _priceOracleWindowInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    wrapToWETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    BALANCER_POOL_TOKEN(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    EXCHANGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAX_ORACLE_WINDOW_SIZE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    NOTE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NOTIONAL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TRADING_MODULE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WETH_INDEX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveBalancer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimBAL(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimVaultRewardTokens(
      vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    coolDownTimeInSeconds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeTrade(
      trade: TradeStruct,
      dexId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastInvestTimestamp(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    manager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceOracleWindowInSeconds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    reinvestVaultReward(
      vault: PromiseOrValue<string>,
      trades: IStrategyVault.SingleSidedRewardTradeParamsStruct[],
      minPoolClaim: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    sNOTE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPriceOracleWindow(
      _priceOracleWindowInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    wrapToWETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
