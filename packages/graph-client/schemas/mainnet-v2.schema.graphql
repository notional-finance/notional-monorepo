schema {
  query: Query
  subscription: Subscription
}
scalar BigDecimal
scalar BigInt
scalar Bytes
type Account {
  "Account address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Timestamp of the next time that the account will require settlement"
  nextSettleTime: BigInt!
  "True if the account's portfolio has debt assets"
  hasPortfolioAssetDebt: Boolean!
  "True if the account's cash balances have debt, may be temporarily inconsistent after a SettleCashEvent"
  hasCashDebt: Boolean!
  "Currency id of an asset bitmap, if set"
  assetBitmapCurrency: Currency
  "Account's balances of both cash and nTokens"
  balances(skip: Int = 0, first: Int = 100, orderBy: Balance_orderBy, orderDirection: OrderDirection, where: Balance_filter): [Balance!]!
  "Account's portfolio assets"
  portfolio(skip: Int = 0, first: Int = 100, orderBy: Asset_orderBy, orderDirection: OrderDirection, where: Asset_filter): [Asset!]!
  "A link to the nToken object if this is an nToken"
  nToken: nToken
  tradeHistory(skip: Int = 0, first: Int = 100, orderBy: Trade_orderBy, orderDirection: OrderDirection, where: Trade_filter): [Trade!]
  balanceChanges(skip: Int = 0, first: Int = 100, orderBy: BalanceChange_orderBy, orderDirection: OrderDirection, where: BalanceChange_filter): [BalanceChange!]
  assetChanges(skip: Int = 0, first: Int = 100, orderBy: AssetChange_orderBy, orderDirection: OrderDirection, where: AssetChange_filter): [AssetChange!]
  nTokenChanges(skip: Int = 0, first: Int = 100, orderBy: nTokenChange_orderBy, orderDirection: OrderDirection, where: nTokenChange_filter): [nTokenChange!]
  leveragedVaults(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultAccount_orderBy, orderDirection: OrderDirection, where: LeveragedVaultAccount_filter): [LeveragedVaultAccount!]
  stakedNoteBalance: StakedNoteBalance
  stakedNoteChanges(skip: Int = 0, first: Int = 100, orderBy: StakedNoteChange_orderBy, orderDirection: OrderDirection, where: StakedNoteChange_filter): [StakedNoteChange!]
}
type Asset {
  "Account:CurrencyId:AssetType:Maturity"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Reference to currency that this balance represents"
  currency: Currency!
  "Timestamp when fCash matures, if liquidity token this will still refer to fCash maturity date"
  maturity: BigInt!
  "Date when assets will be settled, quarterly for liquidity tokens and at maturity for fCash"
  settlementDate: BigInt!
  "Asset type"
  assetType: AssetType!
  "Notional amount"
  notional: BigInt!
}
type AssetChange {
  "Account:CurrencyId:AssetType:Maturity:Transaction hash"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  account: Account!
  currency: Currency!
  maturity: BigInt!
  settlementDate: BigInt!
  assetType: AssetType!
  notionalBefore: BigInt!
  notionalAfter: BigInt!
}
type AssetExchangeRate {
  "Currency id that this asset rate refers to"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Asset currency in the exchange rate"
  assetCurrency: Currency!
  "Asset rate adapter interface to the asset token"
  rateAdapterAddress: Bytes!
  "Decimal places of the underlying token to the asset token"
  underlyingDecimalPlaces: Int!
  "Asset rates that fCash assets will settle at for given maturities"
  settlementRates(skip: Int = 0, first: Int = 100, orderBy: SettlementRate_orderBy, orderDirection: OrderDirection, where: SettlementRate_filter): [SettlementRate!]
}
type AssetExchangeRateHistoricalData {
  id: ID!
  timestamp: Int!
  value: BigInt!
  currency: Currency!
}
type AssetTransfer {
  "from:to:assetId:Transaction hash"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  fromAssetChange: AssetChange!
  toAssetChange: AssetChange!
}
type AuthorizedCallbackContract {
  "Address of the callback contract"
  id: ID!
  name: String!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
}
type Balance {
  "Account Address:Currency ID combination"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Reference to currency that this balance represents"
  currency: Currency!
  "Cash balance denominated in asset cash terms"
  assetCashBalance: BigInt!
  "nToken balance of this currency"
  nTokenBalance: BigInt!
  "Last time token incentives were claimed on this balance"
  lastClaimTime: Int!
  "Last stored integral total supply amount, used to calculate incentives in the original method"
  lastClaimIntegralSupply: BigInt
  "Accumulator for incentive calculation"
  accountIncentiveDebt: BigInt
  "True if the account has migrated to the new incentive scheme"
  didMigrateIncentives: Boolean
}
type BalanceChange {
  "Currency ID:Account:Transaction hash:logIndex"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  account: Account!
  currency: Currency!
  assetCashBalanceBefore: BigInt!
  assetCashBalanceAfter: BigInt!
  assetCashValueUnderlyingBefore: BigInt!
  assetCashValueUnderlyingAfter: BigInt!
  nTokenBalanceBefore: BigInt!
  nTokenBalanceAfter: BigInt!
  nTokenValueAssetBefore: BigInt!
  nTokenValueAssetAfter: BigInt!
  nTokenValueUnderlyingBefore: BigInt!
  nTokenValueUnderlyingAfter: BigInt!
  lastClaimTimeBefore: Int!
  lastClaimTimeAfter: Int!
  lastClaimIntegralSupplyBefore: BigInt
  lastClaimIntegralSupplyAfter: BigInt
  accountIncentiveDebtBefore: BigInt
  accountIncentiveDebtAfter: BigInt
}
type COMPBalance {
  id: ID!
  timestamp: Int!
  value: BigInt!
  usdValue: BigInt!
}
type CashGroup {
  "Currency id that this cash group refers to"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Currency of this cash group"
  currency: Currency!
  "Index of the AMMs on chain that will be made available."
  maxMarketIndex: Int!
  "Maximum length of a market maturity in seconds"
  maxMarketMaturityLengthSeconds: Int!
  "Time window in minutes that the rate oracle will be averaged over"
  rateOracleTimeWindowSeconds: Int!
  "Total fees per trade, specified in basis points"
  totalFeeBasisPoints: Int!
  "Share of the fees given to the protocol, denominated in percentage"
  reserveFeeSharePercent: Int!
  "Debt buffer specified in basis points"
  debtBufferBasisPoints: Int!
  "fCash haircut specified in basis points"
  fCashHaircutBasisPoints: Int!
  "Penalty for settling a negative cash debt in basis points"
  settlementPenaltyRateBasisPoints: Int!
  "Discount on fCash given to the liquidator in basis points"
  liquidationfCashHaircutBasisPoints: Int!
  "Discount on negative fCash given to the liquidator in basis points"
  liquidationDebtBufferBasisPoints: Int!
  "Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100"
  liquidityTokenHaircutsPercent: [Int!]!
  "Rate scalar used to determine the slippage of the market"
  rateScalars: [Int!]!
  "Current size of reserves accumulated for this cash group"
  reserveBalance: BigInt!
  "The minimum threshold of the reserve before they are harvested for buybacks"
  reserveBuffer: BigInt
  nToken: nToken!
}
type Currency {
  "Auto incrementing unique numeric id"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Category of token that this refers to"
  tokenType: TokenType!
  "Name of the asset currency"
  name: String!
  "Symbol of the asset currency"
  symbol: String!
  "Address of asset token"
  tokenAddress: Bytes!
  "Decimals of the asset token"
  decimals: BigInt!
  "If asset token has a transfer fee"
  hasTransferFee: Boolean!
  "Maximum total contract balance for collateral, zero if no limit"
  maxCollateralBalance: BigInt
  "Name of the underlying currency"
  underlyingName: String
  "Symbol of the underlying currency"
  underlyingSymbol: String
  "Address of underlying token"
  underlyingTokenAddress: Bytes
  "Decimals of the underlying token"
  underlyingDecimals: BigInt
  "If underlying token has a transfer fee"
  underlyingHasTransferFee: Boolean
  "Exchange rate from this currency to Eth, used in free collateral calculations"
  ethExchangeRate: EthExchangeRate!
  "Exchange rate from this currency to the underlying asset"
  assetExchangeRate: AssetExchangeRate
  "Cash group for a currency, if exists"
  cashGroup: CashGroup
  "nToken for a currency, if exists"
  nToken: nToken
  "Incentive Migration for a currency, if exists"
  incentiveMigration: IncentiveMigration
  "Hourly data for this currency"
  ethExchangeRateHistoricalData(skip: Int = 0, first: Int = 100, orderBy: EthExchangeRateHistoricalData_orderBy, orderDirection: OrderDirection, where: EthExchangeRateHistoricalData_filter): [EthExchangeRateHistoricalData!]
  assetExchangeRateHistoricalData(skip: Int = 0, first: Int = 100, orderBy: AssetExchangeRateHistoricalData_orderBy, orderDirection: OrderDirection, where: AssetExchangeRateHistoricalData_filter): [AssetExchangeRateHistoricalData!]
  nTokenPresentValueHistoricalData(skip: Int = 0, first: Int = 100, orderBy: NTokenPresentValueHistoricalData_orderBy, orderDirection: OrderDirection, where: NTokenPresentValueHistoricalData_filter): [NTokenPresentValueHistoricalData!]
  "Strategy vaults that use this currency as a primary borrow"
  leveragedVaults(skip: Int = 0, first: Int = 100, orderBy: LeveragedVault_orderBy, orderDirection: OrderDirection, where: LeveragedVault_filter): [LeveragedVault!]
}
type CurrencyTvl {
  id: ID!
  currency: Currency!
  underlyingValue: BigInt!
  usdValue: BigInt!
}
type DailyLendBorrowVolume {
  id: ID!
  date: Int!
  currency: Currency!
  market: Market!
  trades(skip: Int = 0, first: Int = 100, orderBy: Trade_orderBy, orderDirection: OrderDirection, where: Trade_filter): [Trade!]!
  marketIndex: Int!
  tradeType: TradeType!
  totalVolumeUnderlyingCash: BigInt!
  totalVolumeNetAssetCash: BigInt!
  totalVolumeNetfCash: BigInt!
  txCount: BigInt!
}
type Delegate {
  "Ethereum address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  sNOTEVotingPower: BigInt!
  NOTEVotingPower: BigInt!
  totalVotingPower: BigInt!
  account: Account!
  delegatedNote(skip: Int = 0, first: Int = 100, orderBy: NoteBalance_orderBy, orderDirection: OrderDirection, where: NoteBalance_filter): [NoteBalance!]
  delegatedStakedNote(skip: Int = 0, first: Int = 100, orderBy: StakedNoteBalance_orderBy, orderDirection: OrderDirection, where: StakedNoteBalance_filter): [StakedNoteBalance!]
  votingPowerChange(skip: Int = 0, first: Int = 100, orderBy: VotingPowerChange_orderBy, orderDirection: OrderDirection, where: VotingPowerChange_filter): [VotingPowerChange!]
  votes(skip: Int = 0, first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, where: Vote_filter): [Vote!]
  proposals(skip: Int = 0, first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, where: Proposal_filter): [Proposal!]
}
type EthExchangeRate {
  "Currency id that this exchange rate refers to"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Base currency in the exchange rate"
  baseCurrency: Currency!
  "Rate oracle that is used to reference the exchange rate"
  rateOracle: Bytes!
  "Decimal places of the exchange rate"
  rateDecimalPlaces: Int!
  "Does the exchange rate need to invert"
  mustInvert: Boolean!
  "Percentage buffer used when calculating free collateral for debt balances"
  buffer: Int!
  "Percentage haircut used when calculating free collateral for collateral balances"
  haircut: Int!
  "Exchange rate discount given when liquidating this currency"
  liquidationDiscount: Int!
}
type EthExchangeRateHistoricalData {
  id: ID!
  timestamp: Int!
  value: BigInt!
  currency: Currency!
}
type GlobalTransferOperator {
  "Address of the global transfer operator"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
}
type IncentiveMigration {
  "Currency ID of the migrated entity"
  id: ID!
  currency: Currency!
  "Snapshot of the incentive emission rate at migration"
  migrationEmissionRate: BigInt!
  "Snapshot of the integral total supply at migration"
  finalIntegralTotalSupply: BigInt!
  "Time when the currency was migrated"
  migrationTime: BigInt!
}
type LeveragedVault {
  "ID is the address of the vault"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Address of the strategy vault"
  vaultAddress: Bytes!
  "Strategy identifier for the vault"
  strategy: Bytes!
  "Name of the strategy vault"
  name: String!
  "Primary currency the vault borrows in"
  primaryBorrowCurrency: Currency!
  "Minimum amount of primary currency that must be borrowed"
  minAccountBorrowSize: BigInt!
  "Minimum collateral ratio before liquidation"
  minCollateralRatioBasisPoints: Int!
  "Maximum collateral ratio that liquidation can reach"
  maxDeleverageCollateralRatioBasisPoints: Int!
  "Fee assessed on primary borrow paid to the nToken and protocol"
  feeRateBasisPoints: Int!
  "Share of fee paid to protocol reserve"
  reserveFeeSharePercent: Int!
  "Discount rate given to liquidators"
  liquidationRatePercent: Int!
  "Maximum market index for borrowing terms"
  maxBorrowMarketIndex: Int!
  "Secondary borrow currencies (if any)"
  secondaryBorrowCurrencies(skip: Int = 0, first: Int = 100, orderBy: Currency_orderBy, orderDirection: OrderDirection, where: Currency_filter): [Currency!]
  "Max required collateral ratio for vault accounts"
  maxRequiredAccountCollateralRatioBasisPoints: Int
  "Can the vault be entered"
  enabled: Boolean!
  "Allows positions to be rolled forward"
  allowRollPosition: Boolean!
  "Only the vault can enter"
  onlyVaultEntry: Boolean!
  "Only the vault can exit"
  onlyVaultExit: Boolean!
  "Only the vault can roll"
  onlyVaultRoll: Boolean!
  "Only the vault can liquidate"
  onlyVaultDeleverage: Boolean!
  "Only the vault can settle"
  onlyVaultSettle: Boolean!
  "Vault is allowed to re-enter Notional"
  allowsReentrancy: Boolean!
  "Deleveraging is disabled on this vault"
  deleverageDisabled: Boolean
  "All maturities of this strategy vault"
  maturities(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultMaturity_orderBy, orderDirection: OrderDirection, where: LeveragedVaultMaturity_filter): [LeveragedVaultMaturity!]
  vaultCapacity: LeveragedVaultCapacity!
}
type LeveragedVaultAccount {
  "ID is the address of the vault:address of account"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  account: Account!
  leveragedVault: LeveragedVault!
  leveragedVaultMaturity: LeveragedVaultMaturity!
  "Maturity that the account is currently in"
  maturity: Int!
  "Vault shares held in this maturity by the account"
  vaultShares: BigInt!
  "Amount of fCash borrowed"
  primaryBorrowfCash: BigInt!
  "Debt shares of the secondary borrow currencies"
  secondaryBorrowDebtShares: [BigInt!]
  trades(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultTrade_orderBy, orderDirection: OrderDirection, where: LeveragedVaultTrade_filter): [LeveragedVaultTrade!]
}
type LeveragedVaultCapacity {
  "ID is the address of the vault"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  leveragedVault: LeveragedVault!
  maxPrimaryBorrowCapacity: BigInt!
  totalUsedPrimaryBorrowCapacity: BigInt!
  maxSecondaryBorrowCapacity: [BigInt!]
  totalUsedSecondaryBorrowCapacity: [BigInt!]
}
type LeveragedVaultDirectory {
  "ID is always set to 0"
  id: ID!
  listedLeveragedVaults(skip: Int = 0, first: Int = 100, orderBy: LeveragedVault_orderBy, orderDirection: OrderDirection, where: LeveragedVault_filter): [LeveragedVault!]!
}
type LeveragedVaultHistoricalValue {
  "leveragedVault:maturity:timestamp"
  id: ID!
  timestamp: Int!
  leveragedVaultMaturity: LeveragedVaultMaturity!
  "Value of a single strategy token at the given timestamp"
  underlyingValueOfStrategyToken: BigInt!
  "Exchange rate for the primary borrow currency at this timestamp"
  ethExchangeRate: EthExchangeRateHistoricalData!
  "Asset rate for the primary borrow currency at this timestamp"
  assetExchangeRate: AssetExchangeRateHistoricalData!
}
type LeveragedVaultMaturity {
  "ID is the address of the vault:maturity"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  leveragedVault: LeveragedVault!
  "Maturity of the given vault"
  maturity: Int!
  "Total fCash borrowed in the primary currency"
  totalPrimaryfCashBorrowed: BigInt!
  "Total asset cash held in the vault"
  totalAssetCash: BigInt!
  "Total vault shares in the vault"
  totalVaultShares: BigInt!
  "Total strategy tokens in the vault"
  totalStrategyTokens: BigInt!
  "Total secondary fCash borrowed for secondary borrow currencies"
  totalSecondaryfCashBorrowed: [BigInt!]
  "Total secondary debt shares for secondary borrow currencies"
  totalSecondaryDebtShares: [BigInt!]
  "Total fees accrued to the reserve in this maturity"
  totalReserveFeesAccrued: BigInt!
  "Total fees accrued to the nToken in this maturity"
  totalNTokenFeesAccrued: BigInt!
  "True if vault is settled"
  isSettled: Boolean!
  "Timestamp when the vault was settled"
  settlementTimestamp: Int
  "If vault has settled, holds the value of the strategy token"
  settlementStrategyTokenValue: BigInt
  "Snapshot of the secondary borrows in fCash prior to settlement (denominated in primary currency)"
  settlementSecondaryBorrowfCashSnapshot: [BigInt!]
  "Exchange rates between secondary currency and primary currency"
  settlementSecondaryBorrowExchangeRate: [BigInt!]
  "Holds the settlement rate of the primary borrow currency"
  settlementRate: SettlementRate
  "Any shortfall to this vault maturity (if any)"
  shortfall: BigInt
  "Any insolvency to this vault maturity (if any)"
  insolvency: BigInt
  "Asset cash remaining for accounts to withdraw post settlement"
  remainingSettledAssetCash: BigInt
  "Strategy tokens remaining for accounts to withdraw post settlement"
  remainingSettledStrategyTokens: BigInt
  "All strategy vault accounts in this maturity"
  accounts(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultAccount_orderBy, orderDirection: OrderDirection, where: LeveragedVaultAccount_filter): [LeveragedVaultAccount!]
  historicalValue(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultHistoricalValue_orderBy, orderDirection: OrderDirection, where: LeveragedVaultHistoricalValue_filter): [LeveragedVaultHistoricalValue!]
  events(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultMaturityEvent_orderBy, orderDirection: OrderDirection, where: LeveragedVaultMaturityEvent_filter): [LeveragedVaultMaturityEvent!]
}
type LeveragedVaultMaturityEvent {
  "leveragedVault:account or vault address:transaction hash:log index"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  leveragedVaultMaturity: LeveragedVaultMaturity!
  "Net change to strategy tokens"
  netStrategyTokenChange: BigInt!
  "Net change to asset cash"
  netAssetCashChange: BigInt!
}
type LeveragedVaultTrade {
  "leveragedVault:account or vault address:transaction hash:log index"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  vaultTradeType: VaultTradeType!
  account: Account!
  leveragedVault: LeveragedVault!
  leveragedVaultAccount: LeveragedVaultAccount!
  leveragedVaultMaturityBefore: LeveragedVaultMaturity
  leveragedVaultMaturityAfter: LeveragedVaultMaturity
  "Net change to fCash borrowed in the primary currencies"
  primaryBorrowfCashBefore: BigInt!
  primaryBorrowfCashAfter: BigInt!
  netPrimaryBorrowfCashChange: BigInt
  "Net change to vault shares"
  vaultSharesBefore: BigInt!
  vaultSharesAfter: BigInt!
  netVaultSharesChange: BigInt
  "Net change to fCash borrowed in the secondary currencies"
  secondaryDebtSharesBefore: [BigInt!]
  secondaryDebtSharesAfter: [BigInt!]
  netSecondaryDebtSharesChange: [BigInt!]
  "Total change in cash between Notional and the vault, positive on entering, negative on exit"
  netUnderlyingCash: BigInt
  "Net amount of cash that was borrowed or repaid, positive on enter, negative on exit"
  netBorrowedUnderlying: BigInt
  "Net amount of cash that was deposited or withdrawn, positive on enter, negative on exit"
  netDepositUnderlying: BigInt
}
type Liquidation {
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  type: LiquidationType!
  account: Account!
  liquidator: Account!
  localCurrency: Currency!
  netLocalFromLiquidator: BigInt!
  collateralOrFcashCurrency: Currency
  netCollateralTransfer: BigInt
  netNTokenTransfer: BigInt
  fCashMaturities: [BigInt!]
  fCashNotionalTransfer: [BigInt!]
}
type Market {
  "Currency Id:Settlement Date:Maturity combination"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Currency of this market"
  currency: Currency!
  "Date that fCash from this market will mature"
  maturity: Int!
  "Date that this market will settle"
  settlementDate: Int!
  "Market index"
  marketIndex: Int!
  "Length of market maturity in seconds"
  marketMaturityLengthSeconds: Int!
  "Total fCash available in the market"
  totalfCash: BigInt!
  "Total asset cash available in the market"
  totalAssetCash: BigInt!
  "Total liquidity tokens available in the market"
  totalLiquidity: BigInt!
  "Last annualized interest rate the market traded at"
  lastImpliedRate: Int!
  "Oracle rate for the market, must be averaged in using previousTradeTime"
  oracleRate: Int!
  "Last time when a trade occurred on the market"
  previousTradeTime: Int!
  historicalData(skip: Int = 0, first: Int = 100, orderBy: MarketHistoricalData_orderBy, orderDirection: OrderDirection, where: MarketHistoricalData_filter): [MarketHistoricalData!]
}
type MarketHistoricalData {
  "MarketID:Hourly ID for this particular market"
  id: ID!
  market: Market!
  "Total fCash available in the market"
  totalfCash: BigInt!
  "Total asset cash available in the market"
  totalAssetCash: BigInt!
  "Total liquidity tokens available in the market"
  totalLiquidity: BigInt!
  "Last annualized interest rate the market traded at"
  lastImpliedRate: Int!
  "Oracle rate for the market, must be averaged in using previousTradeTime"
  oracleRate: Int!
  "Last time when a trade occurred on the market"
  previousTradeTime: Int!
}
type MarketInitialization {
  "Currency ID:time reference timestamp"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  "Currency of markets"
  currency: Currency!
  "Markets that were initialized during this event"
  markets(skip: Int = 0, first: Int = 100, orderBy: Market_orderBy, orderDirection: OrderDirection, where: Market_filter): [Market!]!
}
type NTokenPresentValueHistoricalData {
  id: ID!
  timestamp: Int!
  pvAsset: BigInt!
  pvUnderlying: BigInt!
  currency: Currency!
}
type NoteBalance {
  "Account address"
  id: ID!
  "Provides a link to a NOTE holder's Notional accounts (if they exist)"
  account: Account!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  delegate: Delegate
  noteBalance: BigInt!
  noteBalanceChanges(skip: Int = 0, first: Int = 100, orderBy: NoteBalanceChange_orderBy, orderDirection: OrderDirection, where: NoteBalanceChange_filter): [NoteBalanceChange!]!
}
type NoteBalanceChange {
  "Account address:TransactionHash:LogIndex"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  account: Account!
  noteBalance: NoteBalance!
  noteBalanceBefore: BigInt!
  noteBalanceAfter: BigInt!
  sender: Bytes!
  receiver: Bytes!
}
type Proposal {
  "Proposal's unique identifier"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  createdAt: Int!
  proposer: Delegate!
  votes(skip: Int = 0, first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, where: Vote_filter): [Vote!]!
  history(skip: Int = 0, first: Int = 100, orderBy: ProposalState_orderBy, orderDirection: OrderDirection, where: ProposalState_filter): [ProposalState!]
  targets: [Bytes!]!
  values: [BigInt!]!
  calldatas: [Bytes!]!
  startBlock: Int!
  endBlock: Int!
  isCancelled: Boolean
  isQueued: Boolean
  isExecuted: Boolean
}
type ProposalState {
  id: ID!
  state: ProposalStateEnum!
  transactionHash: Bytes!
  lastUpdateTimestamp: Int!
}
type Query {
  proposal(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(skip: Int = 0, first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, where: Proposal_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  vote(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vote
  votes(skip: Int = 0, first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, where: Vote_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vote!]!
  delegate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegate
  delegates(skip: Int = 0, first: Int = 100, orderBy: Delegate_orderBy, orderDirection: OrderDirection, where: Delegate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegate!]!
  votingPowerChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VotingPowerChange
  votingPowerChanges(skip: Int = 0, first: Int = 100, orderBy: VotingPowerChange_orderBy, orderDirection: OrderDirection, where: VotingPowerChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VotingPowerChange!]!
  proposalState(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalState
  proposalStates(skip: Int = 0, first: Int = 100, orderBy: ProposalState_orderBy, orderDirection: OrderDirection, where: ProposalState_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalState!]!
  currency(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Currency
  currencies(skip: Int = 0, first: Int = 100, orderBy: Currency_orderBy, orderDirection: OrderDirection, where: Currency_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Currency!]!
  ethExchangeRate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EthExchangeRate
  ethExchangeRates(skip: Int = 0, first: Int = 100, orderBy: EthExchangeRate_orderBy, orderDirection: OrderDirection, where: EthExchangeRate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EthExchangeRate!]!
  assetExchangeRate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetExchangeRate
  assetExchangeRates(skip: Int = 0, first: Int = 100, orderBy: AssetExchangeRate_orderBy, orderDirection: OrderDirection, where: AssetExchangeRate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetExchangeRate!]!
  settlementRate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SettlementRate
  settlementRates(skip: Int = 0, first: Int = 100, orderBy: SettlementRate_orderBy, orderDirection: OrderDirection, where: SettlementRate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SettlementRate!]!
  cashGroup(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CashGroup
  cashGroups(skip: Int = 0, first: Int = 100, orderBy: CashGroup_orderBy, orderDirection: OrderDirection, where: CashGroup_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CashGroup!]!
  nToken(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): nToken
  nTokens(skip: Int = 0, first: Int = 100, orderBy: nToken_orderBy, orderDirection: OrderDirection, where: nToken_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [nToken!]!
  globalTransferOperator(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalTransferOperator
  globalTransferOperators(skip: Int = 0, first: Int = 100, orderBy: GlobalTransferOperator_orderBy, orderDirection: OrderDirection, where: GlobalTransferOperator_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GlobalTransferOperator!]!
  authorizedCallbackContract(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuthorizedCallbackContract
  authorizedCallbackContracts(skip: Int = 0, first: Int = 100, orderBy: AuthorizedCallbackContract_orderBy, orderDirection: OrderDirection, where: AuthorizedCallbackContract_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuthorizedCallbackContract!]!
  secondaryIncentiveRewarder(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SecondaryIncentiveRewarder
  secondaryIncentiveRewarders(skip: Int = 0, first: Int = 100, orderBy: SecondaryIncentiveRewarder_orderBy, orderDirection: OrderDirection, where: SecondaryIncentiveRewarder_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SecondaryIncentiveRewarder!]!
  account(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(skip: Int = 0, first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, where: Account_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  balance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Balance
  balances(skip: Int = 0, first: Int = 100, orderBy: Balance_orderBy, orderDirection: OrderDirection, where: Balance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Balance!]!
  asset(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Asset
  assets(skip: Int = 0, first: Int = 100, orderBy: Asset_orderBy, orderDirection: OrderDirection, where: Asset_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Asset!]!
  market(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(skip: Int = 0, first: Int = 100, orderBy: Market_orderBy, orderDirection: OrderDirection, where: Market_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  marketHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketHistoricalData
  marketHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: MarketHistoricalData_orderBy, orderDirection: OrderDirection, where: MarketHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketHistoricalData!]!
  marketInitialization(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketInitialization
  marketInitializations(skip: Int = 0, first: Int = 100, orderBy: MarketInitialization_orderBy, orderDirection: OrderDirection, where: MarketInitialization_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketInitialization!]!
  trade(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(skip: Int = 0, first: Int = 100, orderBy: Trade_orderBy, orderDirection: OrderDirection, where: Trade_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  balanceChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalanceChange
  balanceChanges(skip: Int = 0, first: Int = 100, orderBy: BalanceChange_orderBy, orderDirection: OrderDirection, where: BalanceChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BalanceChange!]!
  assetChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetChange
  assetChanges(skip: Int = 0, first: Int = 100, orderBy: AssetChange_orderBy, orderDirection: OrderDirection, where: AssetChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetChange!]!
  nTokenChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): nTokenChange
  nTokenChanges(skip: Int = 0, first: Int = 100, orderBy: nTokenChange_orderBy, orderDirection: OrderDirection, where: nTokenChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [nTokenChange!]!
  ethExchangeRateHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EthExchangeRateHistoricalData
  ethExchangeRateHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: EthExchangeRateHistoricalData_orderBy, orderDirection: OrderDirection, where: EthExchangeRateHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EthExchangeRateHistoricalData!]!
  assetExchangeRateHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetExchangeRateHistoricalData
  assetExchangeRateHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: AssetExchangeRateHistoricalData_orderBy, orderDirection: OrderDirection, where: AssetExchangeRateHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetExchangeRateHistoricalData!]!
  ntokenPresentValueHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTokenPresentValueHistoricalData
  ntokenPresentValueHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: NTokenPresentValueHistoricalData_orderBy, orderDirection: OrderDirection, where: NTokenPresentValueHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NTokenPresentValueHistoricalData!]!
  currencyTvl(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CurrencyTvl
  currencyTvls(skip: Int = 0, first: Int = 100, orderBy: CurrencyTvl_orderBy, orderDirection: OrderDirection, where: CurrencyTvl_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CurrencyTvl!]!
  compbalance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): COMPBalance
  compbalances(skip: Int = 0, first: Int = 100, orderBy: COMPBalance_orderBy, orderDirection: OrderDirection, where: COMPBalance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [COMPBalance!]!
  stakedNoteTvl(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteTvl
  stakedNoteTvls(skip: Int = 0, first: Int = 100, orderBy: StakedNoteTvl_orderBy, orderDirection: OrderDirection, where: StakedNoteTvl_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteTvl!]!
  tvlHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TvlHistoricalData
  tvlHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: TvlHistoricalData_orderBy, orderDirection: OrderDirection, where: TvlHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TvlHistoricalData!]!
  assetTransfer(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetTransfer
  assetTransfers(skip: Int = 0, first: Int = 100, orderBy: AssetTransfer_orderBy, orderDirection: OrderDirection, where: AssetTransfer_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetTransfer!]!
  liquidation(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidation
  liquidations(skip: Int = 0, first: Int = 100, orderBy: Liquidation_orderBy, orderDirection: OrderDirection, where: Liquidation_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidation!]!
  dailyLendBorrowVolume(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyLendBorrowVolume
  dailyLendBorrowVolumes(skip: Int = 0, first: Int = 100, orderBy: DailyLendBorrowVolume_orderBy, orderDirection: OrderDirection, where: DailyLendBorrowVolume_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyLendBorrowVolume!]!
  incentiveMigration(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IncentiveMigration
  incentiveMigrations(skip: Int = 0, first: Int = 100, orderBy: IncentiveMigration_orderBy, orderDirection: OrderDirection, where: IncentiveMigration_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IncentiveMigration!]!
  noteBalance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NoteBalance
  noteBalances(skip: Int = 0, first: Int = 100, orderBy: NoteBalance_orderBy, orderDirection: OrderDirection, where: NoteBalance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NoteBalance!]!
  noteBalanceChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NoteBalanceChange
  noteBalanceChanges(skip: Int = 0, first: Int = 100, orderBy: NoteBalanceChange_orderBy, orderDirection: OrderDirection, where: NoteBalanceChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NoteBalanceChange!]!
  stakedNoteBalance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteBalance
  stakedNoteBalances(skip: Int = 0, first: Int = 100, orderBy: StakedNoteBalance_orderBy, orderDirection: OrderDirection, where: StakedNoteBalance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteBalance!]!
  stakedNoteCoolDown(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteCoolDown
  stakedNoteCoolDowns(skip: Int = 0, first: Int = 100, orderBy: StakedNoteCoolDown_orderBy, orderDirection: OrderDirection, where: StakedNoteCoolDown_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteCoolDown!]!
  stakedNoteChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteChange
  stakedNoteChanges(skip: Int = 0, first: Int = 100, orderBy: StakedNoteChange_orderBy, orderDirection: OrderDirection, where: StakedNoteChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteChange!]!
  stakedNotePool(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNotePool
  stakedNotePools(skip: Int = 0, first: Int = 100, orderBy: StakedNotePool_orderBy, orderDirection: OrderDirection, where: StakedNotePool_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNotePool!]!
  stakedNoteInvestment(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteInvestment
  stakedNoteInvestments(skip: Int = 0, first: Int = 100, orderBy: StakedNoteInvestment_orderBy, orderDirection: OrderDirection, where: StakedNoteInvestment_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteInvestment!]!
  treasury(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Treasury
  treasuries(skip: Int = 0, first: Int = 100, orderBy: Treasury_orderBy, orderDirection: OrderDirection, where: Treasury_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Treasury!]!
  treasuryManager(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TreasuryManager
  treasuryManagers(skip: Int = 0, first: Int = 100, orderBy: TreasuryManager_orderBy, orderDirection: OrderDirection, where: TreasuryManager_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TreasuryManager!]!
  treasuryManagerTradingLimit(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TreasuryManagerTradingLimit
  treasuryManagerTradingLimits(skip: Int = 0, first: Int = 100, orderBy: TreasuryManagerTradingLimit_orderBy, orderDirection: OrderDirection, where: TreasuryManagerTradingLimit_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TreasuryManagerTradingLimit!]!
  treasuryTokenTrade(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TreasuryTokenTrade
  treasuryTokenTrades(skip: Int = 0, first: Int = 100, orderBy: TreasuryTokenTrade_orderBy, orderDirection: OrderDirection, where: TreasuryTokenTrade_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TreasuryTokenTrade!]!
  leveragedVaultDirectory(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultDirectory
  leveragedVaultDirectories(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultDirectory_orderBy, orderDirection: OrderDirection, where: LeveragedVaultDirectory_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultDirectory!]!
  leveragedVault(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVault
  leveragedVaults(skip: Int = 0, first: Int = 100, orderBy: LeveragedVault_orderBy, orderDirection: OrderDirection, where: LeveragedVault_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVault!]!
  leveragedVaultCapacity(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultCapacity
  leveragedVaultCapacities(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultCapacity_orderBy, orderDirection: OrderDirection, where: LeveragedVaultCapacity_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultCapacity!]!
  leveragedVaultAccount(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultAccount
  leveragedVaultAccounts(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultAccount_orderBy, orderDirection: OrderDirection, where: LeveragedVaultAccount_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultAccount!]!
  leveragedVaultMaturity(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultMaturity
  leveragedVaultMaturities(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultMaturity_orderBy, orderDirection: OrderDirection, where: LeveragedVaultMaturity_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultMaturity!]!
  leveragedVaultTrade(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultTrade
  leveragedVaultTrades(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultTrade_orderBy, orderDirection: OrderDirection, where: LeveragedVaultTrade_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultTrade!]!
  leveragedVaultMaturityEvent(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultMaturityEvent
  leveragedVaultMaturityEvents(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultMaturityEvent_orderBy, orderDirection: OrderDirection, where: LeveragedVaultMaturityEvent_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultMaturityEvent!]!
  leveragedVaultHistoricalValue(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultHistoricalValue
  leveragedVaultHistoricalValues(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultHistoricalValue_orderBy, orderDirection: OrderDirection, where: LeveragedVaultHistoricalValue_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultHistoricalValue!]!
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
}
type SecondaryIncentiveRewarder {
  "Address of the rewarder contract"
  id: ID!
  currency: Currency!
  nToken: nToken!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
}
type SettlementRate {
  "Currency id and maturity that this settlement rate refers to"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Currency of this settlement rate"
  currency: Currency!
  "Asset exchange rate referenced by this settlement rate"
  assetExchangeRate: AssetExchangeRate!
  "Maturity that this settlement rate refers to"
  maturity: Int!
  "Settlement rate value"
  rate: BigInt!
}
type StakedNoteBalance {
  "Account address"
  id: ID!
  "Provides a link to a staker's Notional accounts (if they exist)"
  account: Account!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  delegate: Delegate
  "Current sNOTE balance of the account"
  sNOTEBalance: BigInt!
  "Total amount of ETH/WETH used to join the pool"
  ethAmountJoined: BigInt!
  "Total amount of NOTE used to join the pool"
  noteAmountJoined: BigInt!
  "Total amount of ethRedeemed from the pool"
  ethAmountRedeemed: BigInt!
  "Total amount of noteRedeemed from the pool"
  noteAmountRedeemed: BigInt!
  currentCoolDown: StakedNoteCoolDown
  coolDowns(skip: Int = 0, first: Int = 100, orderBy: StakedNoteCoolDown_orderBy, orderDirection: OrderDirection, where: StakedNoteCoolDown_filter): [StakedNoteCoolDown!]
  stakedNoteChanges(skip: Int = 0, first: Int = 100, orderBy: StakedNoteChange_orderBy, orderDirection: OrderDirection, where: StakedNoteChange_filter): [StakedNoteChange!]!
}
type StakedNoteChange {
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  account: Account!
  stakedNoteBalance: StakedNoteBalance!
  sNOTEChangeType: sNOTEChangeType!
  sNOTEAmountBefore: BigInt!
  sNOTEAmountAfter: BigInt!
  ethAmountChange: BigInt!
  noteAmountChange: BigInt!
  bptAmountChange: BigInt!
  sender: Bytes
  receiver: Bytes
}
type StakedNoteCoolDown {
  id: ID!
  startedBlockHash: Bytes!
  startedBlockNumber: Int!
  startedTimestamp: Int!
  startedTransactionHash: Bytes!
  endedBlockHash: Bytes
  endedBlockNumber: Int
  endedTimestamp: Int
  endedTransactionHash: Bytes
  stakedNoteBalance: StakedNoteBalance!
  userEndedCoolDown: Boolean
  redeemWindowBegin: Int!
  redeemWindowEnd: Int!
}
type StakedNoteInvestment {
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  "The treasury manager who executed the investment"
  manager: TreasuryManager!
  bptPerSNOTEBefore: BigInt!
  bptPerSNOTEAfter: BigInt!
  totalETHInvested: BigInt!
  totalNOTEInvested: BigInt!
  totalSNOTESupply: BigInt!
}
type StakedNotePool {
  "Staked NOTE address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  totalBPTTokens: BigInt!
  totalSupply: BigInt!
  bptPerSNOTE: BigInt!
}
type StakedNoteTvl {
  id: ID!
  timestamp: Int!
  "Total sNOTE in the pool"
  sNOTETotalSupply: BigInt!
  "Total NOTE in the pool"
  poolNOTEBalance: BigInt!
  "Total ETH in the pool"
  poolETHBalance: BigInt!
  "Total BPT balance in the pool"
  poolBPTBalance: BigInt!
  "NOTE/ETH spot price of the pool"
  spotPrice: BigInt!
  "Total pool value in each relevant denomination using historical spot prices"
  totalPoolValueInNOTE: BigInt!
  totalPoolValueInETH: BigInt!
}
type Subscription {
  proposal(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(skip: Int = 0, first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, where: Proposal_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  vote(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vote
  votes(skip: Int = 0, first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, where: Vote_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vote!]!
  delegate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegate
  delegates(skip: Int = 0, first: Int = 100, orderBy: Delegate_orderBy, orderDirection: OrderDirection, where: Delegate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegate!]!
  votingPowerChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VotingPowerChange
  votingPowerChanges(skip: Int = 0, first: Int = 100, orderBy: VotingPowerChange_orderBy, orderDirection: OrderDirection, where: VotingPowerChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VotingPowerChange!]!
  proposalState(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalState
  proposalStates(skip: Int = 0, first: Int = 100, orderBy: ProposalState_orderBy, orderDirection: OrderDirection, where: ProposalState_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalState!]!
  currency(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Currency
  currencies(skip: Int = 0, first: Int = 100, orderBy: Currency_orderBy, orderDirection: OrderDirection, where: Currency_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Currency!]!
  ethExchangeRate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EthExchangeRate
  ethExchangeRates(skip: Int = 0, first: Int = 100, orderBy: EthExchangeRate_orderBy, orderDirection: OrderDirection, where: EthExchangeRate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EthExchangeRate!]!
  assetExchangeRate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetExchangeRate
  assetExchangeRates(skip: Int = 0, first: Int = 100, orderBy: AssetExchangeRate_orderBy, orderDirection: OrderDirection, where: AssetExchangeRate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetExchangeRate!]!
  settlementRate(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SettlementRate
  settlementRates(skip: Int = 0, first: Int = 100, orderBy: SettlementRate_orderBy, orderDirection: OrderDirection, where: SettlementRate_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SettlementRate!]!
  cashGroup(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CashGroup
  cashGroups(skip: Int = 0, first: Int = 100, orderBy: CashGroup_orderBy, orderDirection: OrderDirection, where: CashGroup_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CashGroup!]!
  nToken(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): nToken
  nTokens(skip: Int = 0, first: Int = 100, orderBy: nToken_orderBy, orderDirection: OrderDirection, where: nToken_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [nToken!]!
  globalTransferOperator(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalTransferOperator
  globalTransferOperators(skip: Int = 0, first: Int = 100, orderBy: GlobalTransferOperator_orderBy, orderDirection: OrderDirection, where: GlobalTransferOperator_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GlobalTransferOperator!]!
  authorizedCallbackContract(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuthorizedCallbackContract
  authorizedCallbackContracts(skip: Int = 0, first: Int = 100, orderBy: AuthorizedCallbackContract_orderBy, orderDirection: OrderDirection, where: AuthorizedCallbackContract_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuthorizedCallbackContract!]!
  secondaryIncentiveRewarder(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SecondaryIncentiveRewarder
  secondaryIncentiveRewarders(skip: Int = 0, first: Int = 100, orderBy: SecondaryIncentiveRewarder_orderBy, orderDirection: OrderDirection, where: SecondaryIncentiveRewarder_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SecondaryIncentiveRewarder!]!
  account(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(skip: Int = 0, first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, where: Account_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  balance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Balance
  balances(skip: Int = 0, first: Int = 100, orderBy: Balance_orderBy, orderDirection: OrderDirection, where: Balance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Balance!]!
  asset(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Asset
  assets(skip: Int = 0, first: Int = 100, orderBy: Asset_orderBy, orderDirection: OrderDirection, where: Asset_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Asset!]!
  market(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(skip: Int = 0, first: Int = 100, orderBy: Market_orderBy, orderDirection: OrderDirection, where: Market_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  marketHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketHistoricalData
  marketHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: MarketHistoricalData_orderBy, orderDirection: OrderDirection, where: MarketHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketHistoricalData!]!
  marketInitialization(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketInitialization
  marketInitializations(skip: Int = 0, first: Int = 100, orderBy: MarketInitialization_orderBy, orderDirection: OrderDirection, where: MarketInitialization_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketInitialization!]!
  trade(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(skip: Int = 0, first: Int = 100, orderBy: Trade_orderBy, orderDirection: OrderDirection, where: Trade_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  balanceChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalanceChange
  balanceChanges(skip: Int = 0, first: Int = 100, orderBy: BalanceChange_orderBy, orderDirection: OrderDirection, where: BalanceChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BalanceChange!]!
  assetChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetChange
  assetChanges(skip: Int = 0, first: Int = 100, orderBy: AssetChange_orderBy, orderDirection: OrderDirection, where: AssetChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetChange!]!
  nTokenChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): nTokenChange
  nTokenChanges(skip: Int = 0, first: Int = 100, orderBy: nTokenChange_orderBy, orderDirection: OrderDirection, where: nTokenChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [nTokenChange!]!
  ethExchangeRateHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EthExchangeRateHistoricalData
  ethExchangeRateHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: EthExchangeRateHistoricalData_orderBy, orderDirection: OrderDirection, where: EthExchangeRateHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EthExchangeRateHistoricalData!]!
  assetExchangeRateHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetExchangeRateHistoricalData
  assetExchangeRateHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: AssetExchangeRateHistoricalData_orderBy, orderDirection: OrderDirection, where: AssetExchangeRateHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetExchangeRateHistoricalData!]!
  ntokenPresentValueHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NTokenPresentValueHistoricalData
  ntokenPresentValueHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: NTokenPresentValueHistoricalData_orderBy, orderDirection: OrderDirection, where: NTokenPresentValueHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NTokenPresentValueHistoricalData!]!
  currencyTvl(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CurrencyTvl
  currencyTvls(skip: Int = 0, first: Int = 100, orderBy: CurrencyTvl_orderBy, orderDirection: OrderDirection, where: CurrencyTvl_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CurrencyTvl!]!
  compbalance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): COMPBalance
  compbalances(skip: Int = 0, first: Int = 100, orderBy: COMPBalance_orderBy, orderDirection: OrderDirection, where: COMPBalance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [COMPBalance!]!
  stakedNoteTvl(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteTvl
  stakedNoteTvls(skip: Int = 0, first: Int = 100, orderBy: StakedNoteTvl_orderBy, orderDirection: OrderDirection, where: StakedNoteTvl_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteTvl!]!
  tvlHistoricalData(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TvlHistoricalData
  tvlHistoricalDatas(skip: Int = 0, first: Int = 100, orderBy: TvlHistoricalData_orderBy, orderDirection: OrderDirection, where: TvlHistoricalData_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TvlHistoricalData!]!
  assetTransfer(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AssetTransfer
  assetTransfers(skip: Int = 0, first: Int = 100, orderBy: AssetTransfer_orderBy, orderDirection: OrderDirection, where: AssetTransfer_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AssetTransfer!]!
  liquidation(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidation
  liquidations(skip: Int = 0, first: Int = 100, orderBy: Liquidation_orderBy, orderDirection: OrderDirection, where: Liquidation_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidation!]!
  dailyLendBorrowVolume(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyLendBorrowVolume
  dailyLendBorrowVolumes(skip: Int = 0, first: Int = 100, orderBy: DailyLendBorrowVolume_orderBy, orderDirection: OrderDirection, where: DailyLendBorrowVolume_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyLendBorrowVolume!]!
  incentiveMigration(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IncentiveMigration
  incentiveMigrations(skip: Int = 0, first: Int = 100, orderBy: IncentiveMigration_orderBy, orderDirection: OrderDirection, where: IncentiveMigration_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IncentiveMigration!]!
  noteBalance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NoteBalance
  noteBalances(skip: Int = 0, first: Int = 100, orderBy: NoteBalance_orderBy, orderDirection: OrderDirection, where: NoteBalance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NoteBalance!]!
  noteBalanceChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NoteBalanceChange
  noteBalanceChanges(skip: Int = 0, first: Int = 100, orderBy: NoteBalanceChange_orderBy, orderDirection: OrderDirection, where: NoteBalanceChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NoteBalanceChange!]!
  stakedNoteBalance(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteBalance
  stakedNoteBalances(skip: Int = 0, first: Int = 100, orderBy: StakedNoteBalance_orderBy, orderDirection: OrderDirection, where: StakedNoteBalance_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteBalance!]!
  stakedNoteCoolDown(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteCoolDown
  stakedNoteCoolDowns(skip: Int = 0, first: Int = 100, orderBy: StakedNoteCoolDown_orderBy, orderDirection: OrderDirection, where: StakedNoteCoolDown_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteCoolDown!]!
  stakedNoteChange(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteChange
  stakedNoteChanges(skip: Int = 0, first: Int = 100, orderBy: StakedNoteChange_orderBy, orderDirection: OrderDirection, where: StakedNoteChange_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteChange!]!
  stakedNotePool(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNotePool
  stakedNotePools(skip: Int = 0, first: Int = 100, orderBy: StakedNotePool_orderBy, orderDirection: OrderDirection, where: StakedNotePool_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNotePool!]!
  stakedNoteInvestment(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakedNoteInvestment
  stakedNoteInvestments(skip: Int = 0, first: Int = 100, orderBy: StakedNoteInvestment_orderBy, orderDirection: OrderDirection, where: StakedNoteInvestment_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakedNoteInvestment!]!
  treasury(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Treasury
  treasuries(skip: Int = 0, first: Int = 100, orderBy: Treasury_orderBy, orderDirection: OrderDirection, where: Treasury_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Treasury!]!
  treasuryManager(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TreasuryManager
  treasuryManagers(skip: Int = 0, first: Int = 100, orderBy: TreasuryManager_orderBy, orderDirection: OrderDirection, where: TreasuryManager_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TreasuryManager!]!
  treasuryManagerTradingLimit(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TreasuryManagerTradingLimit
  treasuryManagerTradingLimits(skip: Int = 0, first: Int = 100, orderBy: TreasuryManagerTradingLimit_orderBy, orderDirection: OrderDirection, where: TreasuryManagerTradingLimit_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TreasuryManagerTradingLimit!]!
  treasuryTokenTrade(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TreasuryTokenTrade
  treasuryTokenTrades(skip: Int = 0, first: Int = 100, orderBy: TreasuryTokenTrade_orderBy, orderDirection: OrderDirection, where: TreasuryTokenTrade_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TreasuryTokenTrade!]!
  leveragedVaultDirectory(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultDirectory
  leveragedVaultDirectories(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultDirectory_orderBy, orderDirection: OrderDirection, where: LeveragedVaultDirectory_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultDirectory!]!
  leveragedVault(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVault
  leveragedVaults(skip: Int = 0, first: Int = 100, orderBy: LeveragedVault_orderBy, orderDirection: OrderDirection, where: LeveragedVault_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVault!]!
  leveragedVaultCapacity(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultCapacity
  leveragedVaultCapacities(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultCapacity_orderBy, orderDirection: OrderDirection, where: LeveragedVaultCapacity_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultCapacity!]!
  leveragedVaultAccount(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultAccount
  leveragedVaultAccounts(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultAccount_orderBy, orderDirection: OrderDirection, where: LeveragedVaultAccount_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultAccount!]!
  leveragedVaultMaturity(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultMaturity
  leveragedVaultMaturities(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultMaturity_orderBy, orderDirection: OrderDirection, where: LeveragedVaultMaturity_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultMaturity!]!
  leveragedVaultTrade(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultTrade
  leveragedVaultTrades(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultTrade_orderBy, orderDirection: OrderDirection, where: LeveragedVaultTrade_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultTrade!]!
  leveragedVaultMaturityEvent(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultMaturityEvent
  leveragedVaultMaturityEvents(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultMaturityEvent_orderBy, orderDirection: OrderDirection, where: LeveragedVaultMaturityEvent_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultMaturityEvent!]!
  leveragedVaultHistoricalValue(id: ID!, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LeveragedVaultHistoricalValue
  leveragedVaultHistoricalValues(skip: Int = 0, first: Int = 100, orderBy: LeveragedVaultHistoricalValue_orderBy, orderDirection: OrderDirection, where: LeveragedVaultHistoricalValue_filter, 
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeveragedVaultHistoricalValue!]!
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
}
type Trade {
  "Currency ID:Account:Transaction hash:logIndex:batchIndex"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  account: Account!
  currency: Currency!
  market: Market
  tradeType: TradeType!
  maturity: BigInt!
  netAssetCash: BigInt!
  netUnderlyingCash: BigInt!
  netfCash: BigInt!
  netLiquidityTokens: BigInt
  transferOperator: Bytes
}
type Treasury {
  "ID hardcoded to zero"
  id: ID!
  contractAddress: Bytes!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  activeManager: TreasuryManager
  investmentCoolDownInSeconds: BigInt
  NOTEPurchaseLimit: BigInt
  tradingLimits(skip: Int = 0, first: Int = 100, orderBy: TreasuryManagerTradingLimit_orderBy, orderDirection: OrderDirection, where: TreasuryManagerTradingLimit_filter): [TreasuryManagerTradingLimit!]
  "A list of all treasury managers"
  managers(skip: Int = 0, first: Int = 100, orderBy: TreasuryManager_orderBy, orderDirection: OrderDirection, where: TreasuryManager_filter): [TreasuryManager!]
}
type TreasuryManager {
  "ID is the manager's ethereum address"
  id: ID!
  startedBlockHash: Bytes!
  startedBlockNumber: Int!
  startedTimestamp: Int!
  startedTransactionHash: Bytes!
  endedBlockHash: Bytes!
  endedBlockNumber: Int!
  endedTimestamp: Int!
  endedTransactionHash: Bytes!
  "Set to true for the manager who is currently active"
  isActiveManager: Boolean!
  treasury: Treasury!
  sNOTEInvestments(skip: Int = 0, first: Int = 100, orderBy: StakedNoteInvestment_orderBy, orderDirection: OrderDirection, where: StakedNoteInvestment_filter): [StakedNoteInvestment!]
  tokenTrades(skip: Int = 0, first: Int = 100, orderBy: TreasuryTokenTrade_orderBy, orderDirection: OrderDirection, where: TreasuryTokenTrade_filter): [TreasuryTokenTrade!]
}
type TreasuryManagerTradingLimit {
  "ID is the token address"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  treasury: Treasury!
  tokenAddress: Bytes!
  symbol: String!
  name: String!
  oracle: Bytes
  slippageLimit: BigInt
}
type TreasuryTokenTrade {
  "ID is the 0x order hash"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  manager: TreasuryManager!
  "Taker that filled the order"
  takerAddress: Bytes!
  "Token that the treasury sold"
  makerAsset: TreasuryManagerTradingLimit!
  "Token that the taker sent back to the treasury"
  takerAsset: Bytes!
  takerAssetSymbol: String
  takerAssetName: String
  takerAssetDecimals: Int
  makerAssetFilledAmount: BigInt!
  takerAssetFilledAmount: BigInt!
  oraclePrice: BigInt
  oracleDecimals: Int
}
type TvlHistoricalData {
  id: ID!
  timestamp: Int!
  usdTotal: BigInt
  perCurrencyTvl(skip: Int = 0, first: Int = 100, orderBy: CurrencyTvl_orderBy, orderDirection: OrderDirection, where: CurrencyTvl_filter): [CurrencyTvl!]
  compBalance: COMPBalance
  sNOTETvl: StakedNoteTvl
}
type Vote {
  "Address and proposal combined as the unique identifier"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  proposal: Proposal!
  delegate: Delegate!
  yesToProposal: Boolean!
  votingPower: BigInt!
}
type VotingPowerChange {
  "TokenAddress:TxnHash:LogIndex"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  source: VotingPowerSource!
  delegate: Delegate!
  votingPowerBefore: BigInt!
  votingPowerAfter: BigInt!
}
type _Block_ {
  "The hash of the block"
  hash: Bytes
  "The block number"
  number: Int!
  "Integer representation of the timestamp stored in blocks for the chain"
  timestamp: Int
}
"The type for the top-level _meta field"
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!
  "The deployment ID"
  deployment: String!
  "If `true`, the subgraph encountered indexing errors at some past block"
  hasIndexingErrors: Boolean!
}
type nToken {
  "Currency id of the nToken"
  id: ID!
  lastUpdateBlockHash: Bytes!
  lastUpdateBlockNumber: Int!
  lastUpdateTimestamp: Int!
  lastUpdateTransactionHash: Bytes!
  "Address of the nToken"
  tokenAddress: Bytes!
  name: String!
  symbol: String!
  decimals: BigInt!
  totalSupply: BigInt!
  integralTotalSupply: BigInt!
  accumulatedNOTEPerNToken: BigInt
  lastSupplyChangeTime: BigInt!
  "Cash group that governs this nToken"
  cashGroup: CashGroup!
  "Currency of this nToken"
  currency: Currency!
  "Proportion of deposits that go into each corresponding market"
  depositShares: [Int!]
  "Maximum market proportion that the nToken will provide liquidity at"
  leverageThresholds: [Int!]
  "Annualized anchor rates used during market initialization"
  annualizedAnchorRates: [Int!]
  "Market proportions used during market initialization"
  proportions: [Int!]
  "Annual incentive emission rate"
  incentiveEmissionRate: BigInt
  "Residual purchase incentive in basis points"
  residualPurchaseIncentiveBasisPoints: Int
  "Seconds until residuals become available to purchase after market initialization"
  residualPurchaseTimeBufferSeconds: Int
  "Basis points of cash withholding for negative fCash"
  cashWithholdingBufferBasisPoints: Int
  "Percentage of the nToken PV that is used during free collateral"
  pvHaircutPercentage: Int
  "Discount on nToken PV given to liquidators"
  liquidationHaircutPercentage: Int
  "Link to the nToken account object"
  account: Account
}
type nTokenChange {
  "nTokenAddress:Transaction hash"
  id: ID!
  blockHash: Bytes!
  blockNumber: Int!
  timestamp: Int!
  transactionHash: Bytes!
  transactionOrigin: Bytes!
  nToken: nToken!
  "Account that mints or redeems nTokens, set to null on initialize markets"
  account: Account
  assetChanges(skip: Int = 0, first: Int = 100, orderBy: AssetChange_orderBy, orderDirection: OrderDirection, where: AssetChange_filter): [AssetChange!]
  balanceChange: BalanceChange
  totalSupplyBefore: BigInt!
  totalSupplyAfter: BigInt!
  "Deprecated integral total supply before and after"
  integralTotalSupplyBefore: BigInt
  integralTotalSupplyAfter: BigInt
  "Last supply change time before and after, equivalent to last accumulated time"
  lastSupplyChangeTimeBefore: BigInt!
  lastSupplyChangeTimeAfter: BigInt!
  "Represents the accumulated NOTE incentives on the nToken"
  accumulatedNOTEPerNTokenBefore: BigInt
  accumulatedNOTEPerNTokenAfter: BigInt
}
enum Account_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  nextSettleTime
  hasPortfolioAssetDebt
  hasCashDebt
  assetBitmapCurrency
  balances
  portfolio
  nToken
  tradeHistory
  balanceChanges
  assetChanges
  nTokenChanges
  leveragedVaults
  stakedNoteBalance
  stakedNoteChanges
}
enum AssetChange_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  account
  currency
  maturity
  settlementDate
  assetType
  notionalBefore
  notionalAfter
}
enum AssetExchangeRateHistoricalData_orderBy {
  id
  timestamp
  value
  currency
}
enum AssetExchangeRate_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  assetCurrency
  rateAdapterAddress
  underlyingDecimalPlaces
  settlementRates
}
enum AssetTransfer_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  fromAssetChange
  toAssetChange
}
enum AssetType {
  fCash
  LiquidityToken_3Month
  LiquidityToken_6Month
  LiquidityToken_1Year
  LiquidityToken_2Year
  LiquidityToken_5Year
  LiquidityToken_10Year
  LiquidityToken_20Year
}
enum Asset_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  currency
  maturity
  settlementDate
  assetType
  notional
}
enum AuthorizedCallbackContract_orderBy {
  id
  name
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
}
enum BalanceChange_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  account
  currency
  assetCashBalanceBefore
  assetCashBalanceAfter
  assetCashValueUnderlyingBefore
  assetCashValueUnderlyingAfter
  nTokenBalanceBefore
  nTokenBalanceAfter
  nTokenValueAssetBefore
  nTokenValueAssetAfter
  nTokenValueUnderlyingBefore
  nTokenValueUnderlyingAfter
  lastClaimTimeBefore
  lastClaimTimeAfter
  lastClaimIntegralSupplyBefore
  lastClaimIntegralSupplyAfter
  accountIncentiveDebtBefore
  accountIncentiveDebtAfter
}
enum Balance_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  currency
  assetCashBalance
  nTokenBalance
  lastClaimTime
  lastClaimIntegralSupply
  accountIncentiveDebt
  didMigrateIncentives
}
enum COMPBalance_orderBy {
  id
  timestamp
  value
  usdValue
}
enum CashGroup_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  currency
  maxMarketIndex
  maxMarketMaturityLengthSeconds
  rateOracleTimeWindowSeconds
  totalFeeBasisPoints
  reserveFeeSharePercent
  debtBufferBasisPoints
  fCashHaircutBasisPoints
  settlementPenaltyRateBasisPoints
  liquidationfCashHaircutBasisPoints
  liquidationDebtBufferBasisPoints
  liquidityTokenHaircutsPercent
  rateScalars
  reserveBalance
  reserveBuffer
  nToken
}
enum CurrencyTvl_orderBy {
  id
  currency
  underlyingValue
  usdValue
}
enum Currency_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  tokenType
  name
  symbol
  tokenAddress
  decimals
  hasTransferFee
  maxCollateralBalance
  underlyingName
  underlyingSymbol
  underlyingTokenAddress
  underlyingDecimals
  underlyingHasTransferFee
  ethExchangeRate
  assetExchangeRate
  cashGroup
  nToken
  incentiveMigration
  ethExchangeRateHistoricalData
  assetExchangeRateHistoricalData
  nTokenPresentValueHistoricalData
  leveragedVaults
}
enum DailyLendBorrowVolume_orderBy {
  id
  date
  currency
  market
  trades
  marketIndex
  tradeType
  totalVolumeUnderlyingCash
  totalVolumeNetAssetCash
  totalVolumeNetfCash
  txCount
}
enum Delegate_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  sNOTEVotingPower
  NOTEVotingPower
  totalVotingPower
  account
  delegatedNote
  delegatedStakedNote
  votingPowerChange
  votes
  proposals
}
enum EthExchangeRateHistoricalData_orderBy {
  id
  timestamp
  value
  currency
}
enum EthExchangeRate_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  baseCurrency
  rateOracle
  rateDecimalPlaces
  mustInvert
  buffer
  haircut
  liquidationDiscount
}
enum GlobalTransferOperator_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
}
enum IncentiveMigration_orderBy {
  id
  currency
  migrationEmissionRate
  finalIntegralTotalSupply
  migrationTime
}
enum LeveragedVaultAccount_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  account
  leveragedVault
  leveragedVaultMaturity
  maturity
  vaultShares
  primaryBorrowfCash
  secondaryBorrowDebtShares
  trades
}
enum LeveragedVaultCapacity_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  leveragedVault
  maxPrimaryBorrowCapacity
  totalUsedPrimaryBorrowCapacity
  maxSecondaryBorrowCapacity
  totalUsedSecondaryBorrowCapacity
}
enum LeveragedVaultDirectory_orderBy {
  id
  listedLeveragedVaults
}
enum LeveragedVaultHistoricalValue_orderBy {
  id
  timestamp
  leveragedVaultMaturity
  underlyingValueOfStrategyToken
  ethExchangeRate
  assetExchangeRate
}
enum LeveragedVaultMaturityEvent_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  leveragedVaultMaturity
  netStrategyTokenChange
  netAssetCashChange
}
enum LeveragedVaultMaturity_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  leveragedVault
  maturity
  totalPrimaryfCashBorrowed
  totalAssetCash
  totalVaultShares
  totalStrategyTokens
  totalSecondaryfCashBorrowed
  totalSecondaryDebtShares
  totalReserveFeesAccrued
  totalNTokenFeesAccrued
  isSettled
  settlementTimestamp
  settlementStrategyTokenValue
  settlementSecondaryBorrowfCashSnapshot
  settlementSecondaryBorrowExchangeRate
  settlementRate
  shortfall
  insolvency
  remainingSettledAssetCash
  remainingSettledStrategyTokens
  accounts
  historicalValue
  events
}
enum LeveragedVaultTrade_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  vaultTradeType
  account
  leveragedVault
  leveragedVaultAccount
  leveragedVaultMaturityBefore
  leveragedVaultMaturityAfter
  primaryBorrowfCashBefore
  primaryBorrowfCashAfter
  netPrimaryBorrowfCashChange
  vaultSharesBefore
  vaultSharesAfter
  netVaultSharesChange
  secondaryDebtSharesBefore
  secondaryDebtSharesAfter
  netSecondaryDebtSharesChange
  netUnderlyingCash
  netBorrowedUnderlying
  netDepositUnderlying
}
enum LeveragedVault_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  vaultAddress
  strategy
  name
  primaryBorrowCurrency
  minAccountBorrowSize
  minCollateralRatioBasisPoints
  maxDeleverageCollateralRatioBasisPoints
  feeRateBasisPoints
  reserveFeeSharePercent
  liquidationRatePercent
  maxBorrowMarketIndex
  secondaryBorrowCurrencies
  maxRequiredAccountCollateralRatioBasisPoints
  enabled
  allowRollPosition
  onlyVaultEntry
  onlyVaultExit
  onlyVaultRoll
  onlyVaultDeleverage
  onlyVaultSettle
  allowsReentrancy
  deleverageDisabled
  maturities
  vaultCapacity
}
enum LiquidationType {
  LocalCurrency
  LocalFcash
  CollateralCurrency
  CrossCurrencyFcash
}
enum Liquidation_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  type
  account
  liquidator
  localCurrency
  netLocalFromLiquidator
  collateralOrFcashCurrency
  netCollateralTransfer
  netNTokenTransfer
  fCashMaturities
  fCashNotionalTransfer
}
enum MarketHistoricalData_orderBy {
  id
  market
  totalfCash
  totalAssetCash
  totalLiquidity
  lastImpliedRate
  oracleRate
  previousTradeTime
}
enum MarketInitialization_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  currency
  markets
}
enum Market_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  currency
  maturity
  settlementDate
  marketIndex
  marketMaturityLengthSeconds
  totalfCash
  totalAssetCash
  totalLiquidity
  lastImpliedRate
  oracleRate
  previousTradeTime
  historicalData
}
enum NTokenPresentValueHistoricalData_orderBy {
  id
  timestamp
  pvAsset
  pvUnderlying
  currency
}
enum NoteBalanceChange_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  account
  noteBalance
  noteBalanceBefore
  noteBalanceAfter
  sender
  receiver
}
enum NoteBalance_orderBy {
  id
  account
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  delegate
  noteBalance
  noteBalanceChanges
}
"Defines the order direction, either ascending or descending"
enum OrderDirection {
  asc
  desc
}
enum ProposalStateEnum {
  PENDING
  CANCELLED
  QUEUED
  EXECUTED
}
enum ProposalState_orderBy {
  id
  state
  transactionHash
  lastUpdateTimestamp
}
enum Proposal_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  createdAt
  proposer
  votes
  history
  targets
  values
  calldatas
  startBlock
  endBlock
  isCancelled
  isQueued
  isExecuted
}
enum SecondaryIncentiveRewarder_orderBy {
  id
  currency
  nToken
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
}
enum SettlementRate_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  currency
  assetExchangeRate
  maturity
  rate
}
enum StakedNoteBalance_orderBy {
  id
  account
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  delegate
  sNOTEBalance
  ethAmountJoined
  noteAmountJoined
  ethAmountRedeemed
  noteAmountRedeemed
  currentCoolDown
  coolDowns
  stakedNoteChanges
}
enum StakedNoteChange_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  account
  stakedNoteBalance
  sNOTEChangeType
  sNOTEAmountBefore
  sNOTEAmountAfter
  ethAmountChange
  noteAmountChange
  bptAmountChange
  sender
  receiver
}
enum StakedNoteCoolDown_orderBy {
  id
  startedBlockHash
  startedBlockNumber
  startedTimestamp
  startedTransactionHash
  endedBlockHash
  endedBlockNumber
  endedTimestamp
  endedTransactionHash
  stakedNoteBalance
  userEndedCoolDown
  redeemWindowBegin
  redeemWindowEnd
}
enum StakedNoteInvestment_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  manager
  bptPerSNOTEBefore
  bptPerSNOTEAfter
  totalETHInvested
  totalNOTEInvested
  totalSNOTESupply
}
enum StakedNotePool_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  totalBPTTokens
  totalSupply
  bptPerSNOTE
}
enum StakedNoteTvl_orderBy {
  id
  timestamp
  sNOTETotalSupply
  poolNOTEBalance
  poolETHBalance
  poolBPTBalance
  spotPrice
  totalPoolValueInNOTE
  totalPoolValueInETH
}
enum TokenType {
  "Token that is the base for a cToken or other mintable token"
  UnderlyingToken
  "Compound interest bearing token"
  cToken
  "Ether specific Compound interest bearing token"
  cETH
  "The one and only Ether"
  Ether
  "A token that cannot be minted as a cToken, but can be used as collateral or traded"
  NonMintable
}
enum TradeType {
  Lend
  Borrow
  AddLiquidity
  RemoveLiquidity
  PurchaseNTokenResidual
  SettleCashDebt
  Transfer
}
enum Trade_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  account
  currency
  market
  tradeType
  maturity
  netAssetCash
  netUnderlyingCash
  netfCash
  netLiquidityTokens
  transferOperator
}
enum TreasuryManagerTradingLimit_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  treasury
  tokenAddress
  symbol
  name
  oracle
  slippageLimit
}
enum TreasuryManager_orderBy {
  id
  startedBlockHash
  startedBlockNumber
  startedTimestamp
  startedTransactionHash
  endedBlockHash
  endedBlockNumber
  endedTimestamp
  endedTransactionHash
  isActiveManager
  treasury
  sNOTEInvestments
  tokenTrades
}
enum TreasuryTokenTrade_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  manager
  takerAddress
  makerAsset
  takerAsset
  takerAssetSymbol
  takerAssetName
  takerAssetDecimals
  makerAssetFilledAmount
  takerAssetFilledAmount
  oraclePrice
  oracleDecimals
}
enum Treasury_orderBy {
  id
  contractAddress
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  activeManager
  investmentCoolDownInSeconds
  NOTEPurchaseLimit
  tradingLimits
  managers
}
enum TvlHistoricalData_orderBy {
  id
  timestamp
  usdTotal
  perCurrencyTvl
  compBalance
  sNOTETvl
}
enum VaultTradeType {
  EnterPosition
  RollPosition
  ExitPreMaturity
  ExitPostMaturity
  DeleverageAccount
  TransferFromDeleverage
  VaultRedeemStrategyToken
  VaultMintStrategyToken
}
enum Vote_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  proposal
  delegate
  yesToProposal
  votingPower
}
enum VotingPowerChange_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  source
  delegate
  votingPowerBefore
  votingPowerAfter
}
enum VotingPowerSource {
  sNOTE
  NOTE
}
enum _SubgraphErrorPolicy_ {
  "Data will be returned even if the subgraph has indexing errors"
  allow
  "If the subgraph has indexing errors, data will be omitted. The default."
  deny
}
enum nTokenChange_orderBy {
  id
  blockHash
  blockNumber
  timestamp
  transactionHash
  transactionOrigin
  nToken
  account
  assetChanges
  balanceChange
  totalSupplyBefore
  totalSupplyAfter
  integralTotalSupplyBefore
  integralTotalSupplyAfter
  lastSupplyChangeTimeBefore
  lastSupplyChangeTimeAfter
  accumulatedNOTEPerNTokenBefore
  accumulatedNOTEPerNTokenAfter
}
enum nToken_orderBy {
  id
  lastUpdateBlockHash
  lastUpdateBlockNumber
  lastUpdateTimestamp
  lastUpdateTransactionHash
  tokenAddress
  name
  symbol
  decimals
  totalSupply
  integralTotalSupply
  accumulatedNOTEPerNToken
  lastSupplyChangeTime
  cashGroup
  currency
  depositShares
  leverageThresholds
  annualizedAnchorRates
  proportions
  incentiveEmissionRate
  residualPurchaseIncentiveBasisPoints
  residualPurchaseTimeBufferSeconds
  cashWithholdingBufferBasisPoints
  pvHaircutPercentage
  liquidationHaircutPercentage
  account
}
enum sNOTEChangeType {
  Transfer
  Stake
  Unstake
}
input Account_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  nextSettleTime: BigInt
  nextSettleTime_not: BigInt
  nextSettleTime_gt: BigInt
  nextSettleTime_lt: BigInt
  nextSettleTime_gte: BigInt
  nextSettleTime_lte: BigInt
  nextSettleTime_in: [BigInt!]
  nextSettleTime_not_in: [BigInt!]
  hasPortfolioAssetDebt: Boolean
  hasPortfolioAssetDebt_not: Boolean
  hasPortfolioAssetDebt_in: [Boolean!]
  hasPortfolioAssetDebt_not_in: [Boolean!]
  hasCashDebt: Boolean
  hasCashDebt_not: Boolean
  hasCashDebt_in: [Boolean!]
  hasCashDebt_not_in: [Boolean!]
  assetBitmapCurrency: String
  assetBitmapCurrency_not: String
  assetBitmapCurrency_gt: String
  assetBitmapCurrency_lt: String
  assetBitmapCurrency_gte: String
  assetBitmapCurrency_lte: String
  assetBitmapCurrency_in: [String!]
  assetBitmapCurrency_not_in: [String!]
  assetBitmapCurrency_contains: String
  assetBitmapCurrency_contains_nocase: String
  assetBitmapCurrency_not_contains: String
  assetBitmapCurrency_not_contains_nocase: String
  assetBitmapCurrency_starts_with: String
  assetBitmapCurrency_starts_with_nocase: String
  assetBitmapCurrency_not_starts_with: String
  assetBitmapCurrency_not_starts_with_nocase: String
  assetBitmapCurrency_ends_with: String
  assetBitmapCurrency_ends_with_nocase: String
  assetBitmapCurrency_not_ends_with: String
  assetBitmapCurrency_not_ends_with_nocase: String
  assetBitmapCurrency_: Currency_filter
  balances: [String!]
  balances_not: [String!]
  balances_contains: [String!]
  balances_contains_nocase: [String!]
  balances_not_contains: [String!]
  balances_not_contains_nocase: [String!]
  balances_: Balance_filter
  portfolio: [String!]
  portfolio_not: [String!]
  portfolio_contains: [String!]
  portfolio_contains_nocase: [String!]
  portfolio_not_contains: [String!]
  portfolio_not_contains_nocase: [String!]
  portfolio_: Asset_filter
  nToken: String
  nToken_not: String
  nToken_gt: String
  nToken_lt: String
  nToken_gte: String
  nToken_lte: String
  nToken_in: [String!]
  nToken_not_in: [String!]
  nToken_contains: String
  nToken_contains_nocase: String
  nToken_not_contains: String
  nToken_not_contains_nocase: String
  nToken_starts_with: String
  nToken_starts_with_nocase: String
  nToken_not_starts_with: String
  nToken_not_starts_with_nocase: String
  nToken_ends_with: String
  nToken_ends_with_nocase: String
  nToken_not_ends_with: String
  nToken_not_ends_with_nocase: String
  nToken_: nToken_filter
  tradeHistory_: Trade_filter
  balanceChanges_: BalanceChange_filter
  assetChanges_: AssetChange_filter
  nTokenChanges_: nTokenChange_filter
  leveragedVaults_: LeveragedVaultAccount_filter
  stakedNoteBalance_: StakedNoteBalance_filter
  stakedNoteChanges_: StakedNoteChange_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input AssetChange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  maturity: BigInt
  maturity_not: BigInt
  maturity_gt: BigInt
  maturity_lt: BigInt
  maturity_gte: BigInt
  maturity_lte: BigInt
  maturity_in: [BigInt!]
  maturity_not_in: [BigInt!]
  settlementDate: BigInt
  settlementDate_not: BigInt
  settlementDate_gt: BigInt
  settlementDate_lt: BigInt
  settlementDate_gte: BigInt
  settlementDate_lte: BigInt
  settlementDate_in: [BigInt!]
  settlementDate_not_in: [BigInt!]
  assetType: AssetType
  assetType_not: AssetType
  assetType_in: [AssetType!]
  assetType_not_in: [AssetType!]
  notionalBefore: BigInt
  notionalBefore_not: BigInt
  notionalBefore_gt: BigInt
  notionalBefore_lt: BigInt
  notionalBefore_gte: BigInt
  notionalBefore_lte: BigInt
  notionalBefore_in: [BigInt!]
  notionalBefore_not_in: [BigInt!]
  notionalAfter: BigInt
  notionalAfter_not: BigInt
  notionalAfter_gt: BigInt
  notionalAfter_lt: BigInt
  notionalAfter_gte: BigInt
  notionalAfter_lte: BigInt
  notionalAfter_in: [BigInt!]
  notionalAfter_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input AssetExchangeRateHistoricalData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input AssetExchangeRate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  assetCurrency: String
  assetCurrency_not: String
  assetCurrency_gt: String
  assetCurrency_lt: String
  assetCurrency_gte: String
  assetCurrency_lte: String
  assetCurrency_in: [String!]
  assetCurrency_not_in: [String!]
  assetCurrency_contains: String
  assetCurrency_contains_nocase: String
  assetCurrency_not_contains: String
  assetCurrency_not_contains_nocase: String
  assetCurrency_starts_with: String
  assetCurrency_starts_with_nocase: String
  assetCurrency_not_starts_with: String
  assetCurrency_not_starts_with_nocase: String
  assetCurrency_ends_with: String
  assetCurrency_ends_with_nocase: String
  assetCurrency_not_ends_with: String
  assetCurrency_not_ends_with_nocase: String
  assetCurrency_: Currency_filter
  rateAdapterAddress: Bytes
  rateAdapterAddress_not: Bytes
  rateAdapterAddress_in: [Bytes!]
  rateAdapterAddress_not_in: [Bytes!]
  rateAdapterAddress_contains: Bytes
  rateAdapterAddress_not_contains: Bytes
  underlyingDecimalPlaces: Int
  underlyingDecimalPlaces_not: Int
  underlyingDecimalPlaces_gt: Int
  underlyingDecimalPlaces_lt: Int
  underlyingDecimalPlaces_gte: Int
  underlyingDecimalPlaces_lte: Int
  underlyingDecimalPlaces_in: [Int!]
  underlyingDecimalPlaces_not_in: [Int!]
  settlementRates_: SettlementRate_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input AssetTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  fromAssetChange: String
  fromAssetChange_not: String
  fromAssetChange_gt: String
  fromAssetChange_lt: String
  fromAssetChange_gte: String
  fromAssetChange_lte: String
  fromAssetChange_in: [String!]
  fromAssetChange_not_in: [String!]
  fromAssetChange_contains: String
  fromAssetChange_contains_nocase: String
  fromAssetChange_not_contains: String
  fromAssetChange_not_contains_nocase: String
  fromAssetChange_starts_with: String
  fromAssetChange_starts_with_nocase: String
  fromAssetChange_not_starts_with: String
  fromAssetChange_not_starts_with_nocase: String
  fromAssetChange_ends_with: String
  fromAssetChange_ends_with_nocase: String
  fromAssetChange_not_ends_with: String
  fromAssetChange_not_ends_with_nocase: String
  fromAssetChange_: AssetChange_filter
  toAssetChange: String
  toAssetChange_not: String
  toAssetChange_gt: String
  toAssetChange_lt: String
  toAssetChange_gte: String
  toAssetChange_lte: String
  toAssetChange_in: [String!]
  toAssetChange_not_in: [String!]
  toAssetChange_contains: String
  toAssetChange_contains_nocase: String
  toAssetChange_not_contains: String
  toAssetChange_not_contains_nocase: String
  toAssetChange_starts_with: String
  toAssetChange_starts_with_nocase: String
  toAssetChange_not_starts_with: String
  toAssetChange_not_starts_with_nocase: String
  toAssetChange_ends_with: String
  toAssetChange_ends_with_nocase: String
  toAssetChange_not_ends_with: String
  toAssetChange_not_ends_with_nocase: String
  toAssetChange_: AssetChange_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  maturity: BigInt
  maturity_not: BigInt
  maturity_gt: BigInt
  maturity_lt: BigInt
  maturity_gte: BigInt
  maturity_lte: BigInt
  maturity_in: [BigInt!]
  maturity_not_in: [BigInt!]
  settlementDate: BigInt
  settlementDate_not: BigInt
  settlementDate_gt: BigInt
  settlementDate_lt: BigInt
  settlementDate_gte: BigInt
  settlementDate_lte: BigInt
  settlementDate_in: [BigInt!]
  settlementDate_not_in: [BigInt!]
  assetType: AssetType
  assetType_not: AssetType
  assetType_in: [AssetType!]
  assetType_not_in: [AssetType!]
  notional: BigInt
  notional_not: BigInt
  notional_gt: BigInt
  notional_lt: BigInt
  notional_gte: BigInt
  notional_lte: BigInt
  notional_in: [BigInt!]
  notional_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input AuthorizedCallbackContract_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input BalanceChange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  assetCashBalanceBefore: BigInt
  assetCashBalanceBefore_not: BigInt
  assetCashBalanceBefore_gt: BigInt
  assetCashBalanceBefore_lt: BigInt
  assetCashBalanceBefore_gte: BigInt
  assetCashBalanceBefore_lte: BigInt
  assetCashBalanceBefore_in: [BigInt!]
  assetCashBalanceBefore_not_in: [BigInt!]
  assetCashBalanceAfter: BigInt
  assetCashBalanceAfter_not: BigInt
  assetCashBalanceAfter_gt: BigInt
  assetCashBalanceAfter_lt: BigInt
  assetCashBalanceAfter_gte: BigInt
  assetCashBalanceAfter_lte: BigInt
  assetCashBalanceAfter_in: [BigInt!]
  assetCashBalanceAfter_not_in: [BigInt!]
  assetCashValueUnderlyingBefore: BigInt
  assetCashValueUnderlyingBefore_not: BigInt
  assetCashValueUnderlyingBefore_gt: BigInt
  assetCashValueUnderlyingBefore_lt: BigInt
  assetCashValueUnderlyingBefore_gte: BigInt
  assetCashValueUnderlyingBefore_lte: BigInt
  assetCashValueUnderlyingBefore_in: [BigInt!]
  assetCashValueUnderlyingBefore_not_in: [BigInt!]
  assetCashValueUnderlyingAfter: BigInt
  assetCashValueUnderlyingAfter_not: BigInt
  assetCashValueUnderlyingAfter_gt: BigInt
  assetCashValueUnderlyingAfter_lt: BigInt
  assetCashValueUnderlyingAfter_gte: BigInt
  assetCashValueUnderlyingAfter_lte: BigInt
  assetCashValueUnderlyingAfter_in: [BigInt!]
  assetCashValueUnderlyingAfter_not_in: [BigInt!]
  nTokenBalanceBefore: BigInt
  nTokenBalanceBefore_not: BigInt
  nTokenBalanceBefore_gt: BigInt
  nTokenBalanceBefore_lt: BigInt
  nTokenBalanceBefore_gte: BigInt
  nTokenBalanceBefore_lte: BigInt
  nTokenBalanceBefore_in: [BigInt!]
  nTokenBalanceBefore_not_in: [BigInt!]
  nTokenBalanceAfter: BigInt
  nTokenBalanceAfter_not: BigInt
  nTokenBalanceAfter_gt: BigInt
  nTokenBalanceAfter_lt: BigInt
  nTokenBalanceAfter_gte: BigInt
  nTokenBalanceAfter_lte: BigInt
  nTokenBalanceAfter_in: [BigInt!]
  nTokenBalanceAfter_not_in: [BigInt!]
  nTokenValueAssetBefore: BigInt
  nTokenValueAssetBefore_not: BigInt
  nTokenValueAssetBefore_gt: BigInt
  nTokenValueAssetBefore_lt: BigInt
  nTokenValueAssetBefore_gte: BigInt
  nTokenValueAssetBefore_lte: BigInt
  nTokenValueAssetBefore_in: [BigInt!]
  nTokenValueAssetBefore_not_in: [BigInt!]
  nTokenValueAssetAfter: BigInt
  nTokenValueAssetAfter_not: BigInt
  nTokenValueAssetAfter_gt: BigInt
  nTokenValueAssetAfter_lt: BigInt
  nTokenValueAssetAfter_gte: BigInt
  nTokenValueAssetAfter_lte: BigInt
  nTokenValueAssetAfter_in: [BigInt!]
  nTokenValueAssetAfter_not_in: [BigInt!]
  nTokenValueUnderlyingBefore: BigInt
  nTokenValueUnderlyingBefore_not: BigInt
  nTokenValueUnderlyingBefore_gt: BigInt
  nTokenValueUnderlyingBefore_lt: BigInt
  nTokenValueUnderlyingBefore_gte: BigInt
  nTokenValueUnderlyingBefore_lte: BigInt
  nTokenValueUnderlyingBefore_in: [BigInt!]
  nTokenValueUnderlyingBefore_not_in: [BigInt!]
  nTokenValueUnderlyingAfter: BigInt
  nTokenValueUnderlyingAfter_not: BigInt
  nTokenValueUnderlyingAfter_gt: BigInt
  nTokenValueUnderlyingAfter_lt: BigInt
  nTokenValueUnderlyingAfter_gte: BigInt
  nTokenValueUnderlyingAfter_lte: BigInt
  nTokenValueUnderlyingAfter_in: [BigInt!]
  nTokenValueUnderlyingAfter_not_in: [BigInt!]
  lastClaimTimeBefore: Int
  lastClaimTimeBefore_not: Int
  lastClaimTimeBefore_gt: Int
  lastClaimTimeBefore_lt: Int
  lastClaimTimeBefore_gte: Int
  lastClaimTimeBefore_lte: Int
  lastClaimTimeBefore_in: [Int!]
  lastClaimTimeBefore_not_in: [Int!]
  lastClaimTimeAfter: Int
  lastClaimTimeAfter_not: Int
  lastClaimTimeAfter_gt: Int
  lastClaimTimeAfter_lt: Int
  lastClaimTimeAfter_gte: Int
  lastClaimTimeAfter_lte: Int
  lastClaimTimeAfter_in: [Int!]
  lastClaimTimeAfter_not_in: [Int!]
  lastClaimIntegralSupplyBefore: BigInt
  lastClaimIntegralSupplyBefore_not: BigInt
  lastClaimIntegralSupplyBefore_gt: BigInt
  lastClaimIntegralSupplyBefore_lt: BigInt
  lastClaimIntegralSupplyBefore_gte: BigInt
  lastClaimIntegralSupplyBefore_lte: BigInt
  lastClaimIntegralSupplyBefore_in: [BigInt!]
  lastClaimIntegralSupplyBefore_not_in: [BigInt!]
  lastClaimIntegralSupplyAfter: BigInt
  lastClaimIntegralSupplyAfter_not: BigInt
  lastClaimIntegralSupplyAfter_gt: BigInt
  lastClaimIntegralSupplyAfter_lt: BigInt
  lastClaimIntegralSupplyAfter_gte: BigInt
  lastClaimIntegralSupplyAfter_lte: BigInt
  lastClaimIntegralSupplyAfter_in: [BigInt!]
  lastClaimIntegralSupplyAfter_not_in: [BigInt!]
  accountIncentiveDebtBefore: BigInt
  accountIncentiveDebtBefore_not: BigInt
  accountIncentiveDebtBefore_gt: BigInt
  accountIncentiveDebtBefore_lt: BigInt
  accountIncentiveDebtBefore_gte: BigInt
  accountIncentiveDebtBefore_lte: BigInt
  accountIncentiveDebtBefore_in: [BigInt!]
  accountIncentiveDebtBefore_not_in: [BigInt!]
  accountIncentiveDebtAfter: BigInt
  accountIncentiveDebtAfter_not: BigInt
  accountIncentiveDebtAfter_gt: BigInt
  accountIncentiveDebtAfter_lt: BigInt
  accountIncentiveDebtAfter_gte: BigInt
  accountIncentiveDebtAfter_lte: BigInt
  accountIncentiveDebtAfter_in: [BigInt!]
  accountIncentiveDebtAfter_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Balance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  assetCashBalance: BigInt
  assetCashBalance_not: BigInt
  assetCashBalance_gt: BigInt
  assetCashBalance_lt: BigInt
  assetCashBalance_gte: BigInt
  assetCashBalance_lte: BigInt
  assetCashBalance_in: [BigInt!]
  assetCashBalance_not_in: [BigInt!]
  nTokenBalance: BigInt
  nTokenBalance_not: BigInt
  nTokenBalance_gt: BigInt
  nTokenBalance_lt: BigInt
  nTokenBalance_gte: BigInt
  nTokenBalance_lte: BigInt
  nTokenBalance_in: [BigInt!]
  nTokenBalance_not_in: [BigInt!]
  lastClaimTime: Int
  lastClaimTime_not: Int
  lastClaimTime_gt: Int
  lastClaimTime_lt: Int
  lastClaimTime_gte: Int
  lastClaimTime_lte: Int
  lastClaimTime_in: [Int!]
  lastClaimTime_not_in: [Int!]
  lastClaimIntegralSupply: BigInt
  lastClaimIntegralSupply_not: BigInt
  lastClaimIntegralSupply_gt: BigInt
  lastClaimIntegralSupply_lt: BigInt
  lastClaimIntegralSupply_gte: BigInt
  lastClaimIntegralSupply_lte: BigInt
  lastClaimIntegralSupply_in: [BigInt!]
  lastClaimIntegralSupply_not_in: [BigInt!]
  accountIncentiveDebt: BigInt
  accountIncentiveDebt_not: BigInt
  accountIncentiveDebt_gt: BigInt
  accountIncentiveDebt_lt: BigInt
  accountIncentiveDebt_gte: BigInt
  accountIncentiveDebt_lte: BigInt
  accountIncentiveDebt_in: [BigInt!]
  accountIncentiveDebt_not_in: [BigInt!]
  didMigrateIncentives: Boolean
  didMigrateIncentives_not: Boolean
  didMigrateIncentives_in: [Boolean!]
  didMigrateIncentives_not_in: [Boolean!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input BlockChangedFilter {
  number_gte: Int!
}
input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}
input COMPBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  usdValue: BigInt
  usdValue_not: BigInt
  usdValue_gt: BigInt
  usdValue_lt: BigInt
  usdValue_gte: BigInt
  usdValue_lte: BigInt
  usdValue_in: [BigInt!]
  usdValue_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input CashGroup_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  maxMarketIndex: Int
  maxMarketIndex_not: Int
  maxMarketIndex_gt: Int
  maxMarketIndex_lt: Int
  maxMarketIndex_gte: Int
  maxMarketIndex_lte: Int
  maxMarketIndex_in: [Int!]
  maxMarketIndex_not_in: [Int!]
  maxMarketMaturityLengthSeconds: Int
  maxMarketMaturityLengthSeconds_not: Int
  maxMarketMaturityLengthSeconds_gt: Int
  maxMarketMaturityLengthSeconds_lt: Int
  maxMarketMaturityLengthSeconds_gte: Int
  maxMarketMaturityLengthSeconds_lte: Int
  maxMarketMaturityLengthSeconds_in: [Int!]
  maxMarketMaturityLengthSeconds_not_in: [Int!]
  rateOracleTimeWindowSeconds: Int
  rateOracleTimeWindowSeconds_not: Int
  rateOracleTimeWindowSeconds_gt: Int
  rateOracleTimeWindowSeconds_lt: Int
  rateOracleTimeWindowSeconds_gte: Int
  rateOracleTimeWindowSeconds_lte: Int
  rateOracleTimeWindowSeconds_in: [Int!]
  rateOracleTimeWindowSeconds_not_in: [Int!]
  totalFeeBasisPoints: Int
  totalFeeBasisPoints_not: Int
  totalFeeBasisPoints_gt: Int
  totalFeeBasisPoints_lt: Int
  totalFeeBasisPoints_gte: Int
  totalFeeBasisPoints_lte: Int
  totalFeeBasisPoints_in: [Int!]
  totalFeeBasisPoints_not_in: [Int!]
  reserveFeeSharePercent: Int
  reserveFeeSharePercent_not: Int
  reserveFeeSharePercent_gt: Int
  reserveFeeSharePercent_lt: Int
  reserveFeeSharePercent_gte: Int
  reserveFeeSharePercent_lte: Int
  reserveFeeSharePercent_in: [Int!]
  reserveFeeSharePercent_not_in: [Int!]
  debtBufferBasisPoints: Int
  debtBufferBasisPoints_not: Int
  debtBufferBasisPoints_gt: Int
  debtBufferBasisPoints_lt: Int
  debtBufferBasisPoints_gte: Int
  debtBufferBasisPoints_lte: Int
  debtBufferBasisPoints_in: [Int!]
  debtBufferBasisPoints_not_in: [Int!]
  fCashHaircutBasisPoints: Int
  fCashHaircutBasisPoints_not: Int
  fCashHaircutBasisPoints_gt: Int
  fCashHaircutBasisPoints_lt: Int
  fCashHaircutBasisPoints_gte: Int
  fCashHaircutBasisPoints_lte: Int
  fCashHaircutBasisPoints_in: [Int!]
  fCashHaircutBasisPoints_not_in: [Int!]
  settlementPenaltyRateBasisPoints: Int
  settlementPenaltyRateBasisPoints_not: Int
  settlementPenaltyRateBasisPoints_gt: Int
  settlementPenaltyRateBasisPoints_lt: Int
  settlementPenaltyRateBasisPoints_gte: Int
  settlementPenaltyRateBasisPoints_lte: Int
  settlementPenaltyRateBasisPoints_in: [Int!]
  settlementPenaltyRateBasisPoints_not_in: [Int!]
  liquidationfCashHaircutBasisPoints: Int
  liquidationfCashHaircutBasisPoints_not: Int
  liquidationfCashHaircutBasisPoints_gt: Int
  liquidationfCashHaircutBasisPoints_lt: Int
  liquidationfCashHaircutBasisPoints_gte: Int
  liquidationfCashHaircutBasisPoints_lte: Int
  liquidationfCashHaircutBasisPoints_in: [Int!]
  liquidationfCashHaircutBasisPoints_not_in: [Int!]
  liquidationDebtBufferBasisPoints: Int
  liquidationDebtBufferBasisPoints_not: Int
  liquidationDebtBufferBasisPoints_gt: Int
  liquidationDebtBufferBasisPoints_lt: Int
  liquidationDebtBufferBasisPoints_gte: Int
  liquidationDebtBufferBasisPoints_lte: Int
  liquidationDebtBufferBasisPoints_in: [Int!]
  liquidationDebtBufferBasisPoints_not_in: [Int!]
  liquidityTokenHaircutsPercent: [Int!]
  liquidityTokenHaircutsPercent_not: [Int!]
  liquidityTokenHaircutsPercent_contains: [Int!]
  liquidityTokenHaircutsPercent_contains_nocase: [Int!]
  liquidityTokenHaircutsPercent_not_contains: [Int!]
  liquidityTokenHaircutsPercent_not_contains_nocase: [Int!]
  rateScalars: [Int!]
  rateScalars_not: [Int!]
  rateScalars_contains: [Int!]
  rateScalars_contains_nocase: [Int!]
  rateScalars_not_contains: [Int!]
  rateScalars_not_contains_nocase: [Int!]
  reserveBalance: BigInt
  reserveBalance_not: BigInt
  reserveBalance_gt: BigInt
  reserveBalance_lt: BigInt
  reserveBalance_gte: BigInt
  reserveBalance_lte: BigInt
  reserveBalance_in: [BigInt!]
  reserveBalance_not_in: [BigInt!]
  reserveBuffer: BigInt
  reserveBuffer_not: BigInt
  reserveBuffer_gt: BigInt
  reserveBuffer_lt: BigInt
  reserveBuffer_gte: BigInt
  reserveBuffer_lte: BigInt
  reserveBuffer_in: [BigInt!]
  reserveBuffer_not_in: [BigInt!]
  nToken_: nToken_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input CurrencyTvl_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  underlyingValue: BigInt
  underlyingValue_not: BigInt
  underlyingValue_gt: BigInt
  underlyingValue_lt: BigInt
  underlyingValue_gte: BigInt
  underlyingValue_lte: BigInt
  underlyingValue_in: [BigInt!]
  underlyingValue_not_in: [BigInt!]
  usdValue: BigInt
  usdValue_not: BigInt
  usdValue_gt: BigInt
  usdValue_lt: BigInt
  usdValue_gte: BigInt
  usdValue_lte: BigInt
  usdValue_in: [BigInt!]
  usdValue_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Currency_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  tokenType: TokenType
  tokenType_not: TokenType
  tokenType_in: [TokenType!]
  tokenType_not_in: [TokenType!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  tokenAddress: Bytes
  tokenAddress_not: Bytes
  tokenAddress_in: [Bytes!]
  tokenAddress_not_in: [Bytes!]
  tokenAddress_contains: Bytes
  tokenAddress_not_contains: Bytes
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  hasTransferFee: Boolean
  hasTransferFee_not: Boolean
  hasTransferFee_in: [Boolean!]
  hasTransferFee_not_in: [Boolean!]
  maxCollateralBalance: BigInt
  maxCollateralBalance_not: BigInt
  maxCollateralBalance_gt: BigInt
  maxCollateralBalance_lt: BigInt
  maxCollateralBalance_gte: BigInt
  maxCollateralBalance_lte: BigInt
  maxCollateralBalance_in: [BigInt!]
  maxCollateralBalance_not_in: [BigInt!]
  underlyingName: String
  underlyingName_not: String
  underlyingName_gt: String
  underlyingName_lt: String
  underlyingName_gte: String
  underlyingName_lte: String
  underlyingName_in: [String!]
  underlyingName_not_in: [String!]
  underlyingName_contains: String
  underlyingName_contains_nocase: String
  underlyingName_not_contains: String
  underlyingName_not_contains_nocase: String
  underlyingName_starts_with: String
  underlyingName_starts_with_nocase: String
  underlyingName_not_starts_with: String
  underlyingName_not_starts_with_nocase: String
  underlyingName_ends_with: String
  underlyingName_ends_with_nocase: String
  underlyingName_not_ends_with: String
  underlyingName_not_ends_with_nocase: String
  underlyingSymbol: String
  underlyingSymbol_not: String
  underlyingSymbol_gt: String
  underlyingSymbol_lt: String
  underlyingSymbol_gte: String
  underlyingSymbol_lte: String
  underlyingSymbol_in: [String!]
  underlyingSymbol_not_in: [String!]
  underlyingSymbol_contains: String
  underlyingSymbol_contains_nocase: String
  underlyingSymbol_not_contains: String
  underlyingSymbol_not_contains_nocase: String
  underlyingSymbol_starts_with: String
  underlyingSymbol_starts_with_nocase: String
  underlyingSymbol_not_starts_with: String
  underlyingSymbol_not_starts_with_nocase: String
  underlyingSymbol_ends_with: String
  underlyingSymbol_ends_with_nocase: String
  underlyingSymbol_not_ends_with: String
  underlyingSymbol_not_ends_with_nocase: String
  underlyingTokenAddress: Bytes
  underlyingTokenAddress_not: Bytes
  underlyingTokenAddress_in: [Bytes!]
  underlyingTokenAddress_not_in: [Bytes!]
  underlyingTokenAddress_contains: Bytes
  underlyingTokenAddress_not_contains: Bytes
  underlyingDecimals: BigInt
  underlyingDecimals_not: BigInt
  underlyingDecimals_gt: BigInt
  underlyingDecimals_lt: BigInt
  underlyingDecimals_gte: BigInt
  underlyingDecimals_lte: BigInt
  underlyingDecimals_in: [BigInt!]
  underlyingDecimals_not_in: [BigInt!]
  underlyingHasTransferFee: Boolean
  underlyingHasTransferFee_not: Boolean
  underlyingHasTransferFee_in: [Boolean!]
  underlyingHasTransferFee_not_in: [Boolean!]
  ethExchangeRate_: EthExchangeRate_filter
  assetExchangeRate_: AssetExchangeRate_filter
  cashGroup_: CashGroup_filter
  nToken_: nToken_filter
  incentiveMigration_: IncentiveMigration_filter
  ethExchangeRateHistoricalData_: EthExchangeRateHistoricalData_filter
  assetExchangeRateHistoricalData_: AssetExchangeRateHistoricalData_filter
  nTokenPresentValueHistoricalData_: NTokenPresentValueHistoricalData_filter
  leveragedVaults_: LeveragedVault_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input DailyLendBorrowVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter
  trades: [String!]
  trades_not: [String!]
  trades_contains: [String!]
  trades_contains_nocase: [String!]
  trades_not_contains: [String!]
  trades_not_contains_nocase: [String!]
  trades_: Trade_filter
  marketIndex: Int
  marketIndex_not: Int
  marketIndex_gt: Int
  marketIndex_lt: Int
  marketIndex_gte: Int
  marketIndex_lte: Int
  marketIndex_in: [Int!]
  marketIndex_not_in: [Int!]
  tradeType: TradeType
  tradeType_not: TradeType
  tradeType_in: [TradeType!]
  tradeType_not_in: [TradeType!]
  totalVolumeUnderlyingCash: BigInt
  totalVolumeUnderlyingCash_not: BigInt
  totalVolumeUnderlyingCash_gt: BigInt
  totalVolumeUnderlyingCash_lt: BigInt
  totalVolumeUnderlyingCash_gte: BigInt
  totalVolumeUnderlyingCash_lte: BigInt
  totalVolumeUnderlyingCash_in: [BigInt!]
  totalVolumeUnderlyingCash_not_in: [BigInt!]
  totalVolumeNetAssetCash: BigInt
  totalVolumeNetAssetCash_not: BigInt
  totalVolumeNetAssetCash_gt: BigInt
  totalVolumeNetAssetCash_lt: BigInt
  totalVolumeNetAssetCash_gte: BigInt
  totalVolumeNetAssetCash_lte: BigInt
  totalVolumeNetAssetCash_in: [BigInt!]
  totalVolumeNetAssetCash_not_in: [BigInt!]
  totalVolumeNetfCash: BigInt
  totalVolumeNetfCash_not: BigInt
  totalVolumeNetfCash_gt: BigInt
  totalVolumeNetfCash_lt: BigInt
  totalVolumeNetfCash_gte: BigInt
  totalVolumeNetfCash_lte: BigInt
  totalVolumeNetfCash_in: [BigInt!]
  totalVolumeNetfCash_not_in: [BigInt!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Delegate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  sNOTEVotingPower: BigInt
  sNOTEVotingPower_not: BigInt
  sNOTEVotingPower_gt: BigInt
  sNOTEVotingPower_lt: BigInt
  sNOTEVotingPower_gte: BigInt
  sNOTEVotingPower_lte: BigInt
  sNOTEVotingPower_in: [BigInt!]
  sNOTEVotingPower_not_in: [BigInt!]
  NOTEVotingPower: BigInt
  NOTEVotingPower_not: BigInt
  NOTEVotingPower_gt: BigInt
  NOTEVotingPower_lt: BigInt
  NOTEVotingPower_gte: BigInt
  NOTEVotingPower_lte: BigInt
  NOTEVotingPower_in: [BigInt!]
  NOTEVotingPower_not_in: [BigInt!]
  totalVotingPower: BigInt
  totalVotingPower_not: BigInt
  totalVotingPower_gt: BigInt
  totalVotingPower_lt: BigInt
  totalVotingPower_gte: BigInt
  totalVotingPower_lte: BigInt
  totalVotingPower_in: [BigInt!]
  totalVotingPower_not_in: [BigInt!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  delegatedNote_: NoteBalance_filter
  delegatedStakedNote_: StakedNoteBalance_filter
  votingPowerChange_: VotingPowerChange_filter
  votes_: Vote_filter
  proposals_: Proposal_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input EthExchangeRateHistoricalData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input EthExchangeRate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  baseCurrency: String
  baseCurrency_not: String
  baseCurrency_gt: String
  baseCurrency_lt: String
  baseCurrency_gte: String
  baseCurrency_lte: String
  baseCurrency_in: [String!]
  baseCurrency_not_in: [String!]
  baseCurrency_contains: String
  baseCurrency_contains_nocase: String
  baseCurrency_not_contains: String
  baseCurrency_not_contains_nocase: String
  baseCurrency_starts_with: String
  baseCurrency_starts_with_nocase: String
  baseCurrency_not_starts_with: String
  baseCurrency_not_starts_with_nocase: String
  baseCurrency_ends_with: String
  baseCurrency_ends_with_nocase: String
  baseCurrency_not_ends_with: String
  baseCurrency_not_ends_with_nocase: String
  baseCurrency_: Currency_filter
  rateOracle: Bytes
  rateOracle_not: Bytes
  rateOracle_in: [Bytes!]
  rateOracle_not_in: [Bytes!]
  rateOracle_contains: Bytes
  rateOracle_not_contains: Bytes
  rateDecimalPlaces: Int
  rateDecimalPlaces_not: Int
  rateDecimalPlaces_gt: Int
  rateDecimalPlaces_lt: Int
  rateDecimalPlaces_gte: Int
  rateDecimalPlaces_lte: Int
  rateDecimalPlaces_in: [Int!]
  rateDecimalPlaces_not_in: [Int!]
  mustInvert: Boolean
  mustInvert_not: Boolean
  mustInvert_in: [Boolean!]
  mustInvert_not_in: [Boolean!]
  buffer: Int
  buffer_not: Int
  buffer_gt: Int
  buffer_lt: Int
  buffer_gte: Int
  buffer_lte: Int
  buffer_in: [Int!]
  buffer_not_in: [Int!]
  haircut: Int
  haircut_not: Int
  haircut_gt: Int
  haircut_lt: Int
  haircut_gte: Int
  haircut_lte: Int
  haircut_in: [Int!]
  haircut_not_in: [Int!]
  liquidationDiscount: Int
  liquidationDiscount_not: Int
  liquidationDiscount_gt: Int
  liquidationDiscount_lt: Int
  liquidationDiscount_gte: Int
  liquidationDiscount_lte: Int
  liquidationDiscount_in: [Int!]
  liquidationDiscount_not_in: [Int!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input GlobalTransferOperator_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input IncentiveMigration_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  migrationEmissionRate: BigInt
  migrationEmissionRate_not: BigInt
  migrationEmissionRate_gt: BigInt
  migrationEmissionRate_lt: BigInt
  migrationEmissionRate_gte: BigInt
  migrationEmissionRate_lte: BigInt
  migrationEmissionRate_in: [BigInt!]
  migrationEmissionRate_not_in: [BigInt!]
  finalIntegralTotalSupply: BigInt
  finalIntegralTotalSupply_not: BigInt
  finalIntegralTotalSupply_gt: BigInt
  finalIntegralTotalSupply_lt: BigInt
  finalIntegralTotalSupply_gte: BigInt
  finalIntegralTotalSupply_lte: BigInt
  finalIntegralTotalSupply_in: [BigInt!]
  finalIntegralTotalSupply_not_in: [BigInt!]
  migrationTime: BigInt
  migrationTime_not: BigInt
  migrationTime_gt: BigInt
  migrationTime_lt: BigInt
  migrationTime_gte: BigInt
  migrationTime_lte: BigInt
  migrationTime_in: [BigInt!]
  migrationTime_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVaultAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  leveragedVault: String
  leveragedVault_not: String
  leveragedVault_gt: String
  leveragedVault_lt: String
  leveragedVault_gte: String
  leveragedVault_lte: String
  leveragedVault_in: [String!]
  leveragedVault_not_in: [String!]
  leveragedVault_contains: String
  leveragedVault_contains_nocase: String
  leveragedVault_not_contains: String
  leveragedVault_not_contains_nocase: String
  leveragedVault_starts_with: String
  leveragedVault_starts_with_nocase: String
  leveragedVault_not_starts_with: String
  leveragedVault_not_starts_with_nocase: String
  leveragedVault_ends_with: String
  leveragedVault_ends_with_nocase: String
  leveragedVault_not_ends_with: String
  leveragedVault_not_ends_with_nocase: String
  leveragedVault_: LeveragedVault_filter
  leveragedVaultMaturity: String
  leveragedVaultMaturity_not: String
  leveragedVaultMaturity_gt: String
  leveragedVaultMaturity_lt: String
  leveragedVaultMaturity_gte: String
  leveragedVaultMaturity_lte: String
  leveragedVaultMaturity_in: [String!]
  leveragedVaultMaturity_not_in: [String!]
  leveragedVaultMaturity_contains: String
  leveragedVaultMaturity_contains_nocase: String
  leveragedVaultMaturity_not_contains: String
  leveragedVaultMaturity_not_contains_nocase: String
  leveragedVaultMaturity_starts_with: String
  leveragedVaultMaturity_starts_with_nocase: String
  leveragedVaultMaturity_not_starts_with: String
  leveragedVaultMaturity_not_starts_with_nocase: String
  leveragedVaultMaturity_ends_with: String
  leveragedVaultMaturity_ends_with_nocase: String
  leveragedVaultMaturity_not_ends_with: String
  leveragedVaultMaturity_not_ends_with_nocase: String
  leveragedVaultMaturity_: LeveragedVaultMaturity_filter
  maturity: Int
  maturity_not: Int
  maturity_gt: Int
  maturity_lt: Int
  maturity_gte: Int
  maturity_lte: Int
  maturity_in: [Int!]
  maturity_not_in: [Int!]
  vaultShares: BigInt
  vaultShares_not: BigInt
  vaultShares_gt: BigInt
  vaultShares_lt: BigInt
  vaultShares_gte: BigInt
  vaultShares_lte: BigInt
  vaultShares_in: [BigInt!]
  vaultShares_not_in: [BigInt!]
  primaryBorrowfCash: BigInt
  primaryBorrowfCash_not: BigInt
  primaryBorrowfCash_gt: BigInt
  primaryBorrowfCash_lt: BigInt
  primaryBorrowfCash_gte: BigInt
  primaryBorrowfCash_lte: BigInt
  primaryBorrowfCash_in: [BigInt!]
  primaryBorrowfCash_not_in: [BigInt!]
  secondaryBorrowDebtShares: [BigInt!]
  secondaryBorrowDebtShares_not: [BigInt!]
  secondaryBorrowDebtShares_contains: [BigInt!]
  secondaryBorrowDebtShares_contains_nocase: [BigInt!]
  secondaryBorrowDebtShares_not_contains: [BigInt!]
  secondaryBorrowDebtShares_not_contains_nocase: [BigInt!]
  trades_: LeveragedVaultTrade_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVaultCapacity_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  leveragedVault: String
  leveragedVault_not: String
  leveragedVault_gt: String
  leveragedVault_lt: String
  leveragedVault_gte: String
  leveragedVault_lte: String
  leveragedVault_in: [String!]
  leveragedVault_not_in: [String!]
  leveragedVault_contains: String
  leveragedVault_contains_nocase: String
  leveragedVault_not_contains: String
  leveragedVault_not_contains_nocase: String
  leveragedVault_starts_with: String
  leveragedVault_starts_with_nocase: String
  leveragedVault_not_starts_with: String
  leveragedVault_not_starts_with_nocase: String
  leveragedVault_ends_with: String
  leveragedVault_ends_with_nocase: String
  leveragedVault_not_ends_with: String
  leveragedVault_not_ends_with_nocase: String
  leveragedVault_: LeveragedVault_filter
  maxPrimaryBorrowCapacity: BigInt
  maxPrimaryBorrowCapacity_not: BigInt
  maxPrimaryBorrowCapacity_gt: BigInt
  maxPrimaryBorrowCapacity_lt: BigInt
  maxPrimaryBorrowCapacity_gte: BigInt
  maxPrimaryBorrowCapacity_lte: BigInt
  maxPrimaryBorrowCapacity_in: [BigInt!]
  maxPrimaryBorrowCapacity_not_in: [BigInt!]
  totalUsedPrimaryBorrowCapacity: BigInt
  totalUsedPrimaryBorrowCapacity_not: BigInt
  totalUsedPrimaryBorrowCapacity_gt: BigInt
  totalUsedPrimaryBorrowCapacity_lt: BigInt
  totalUsedPrimaryBorrowCapacity_gte: BigInt
  totalUsedPrimaryBorrowCapacity_lte: BigInt
  totalUsedPrimaryBorrowCapacity_in: [BigInt!]
  totalUsedPrimaryBorrowCapacity_not_in: [BigInt!]
  maxSecondaryBorrowCapacity: [BigInt!]
  maxSecondaryBorrowCapacity_not: [BigInt!]
  maxSecondaryBorrowCapacity_contains: [BigInt!]
  maxSecondaryBorrowCapacity_contains_nocase: [BigInt!]
  maxSecondaryBorrowCapacity_not_contains: [BigInt!]
  maxSecondaryBorrowCapacity_not_contains_nocase: [BigInt!]
  totalUsedSecondaryBorrowCapacity: [BigInt!]
  totalUsedSecondaryBorrowCapacity_not: [BigInt!]
  totalUsedSecondaryBorrowCapacity_contains: [BigInt!]
  totalUsedSecondaryBorrowCapacity_contains_nocase: [BigInt!]
  totalUsedSecondaryBorrowCapacity_not_contains: [BigInt!]
  totalUsedSecondaryBorrowCapacity_not_contains_nocase: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVaultDirectory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  listedLeveragedVaults: [String!]
  listedLeveragedVaults_not: [String!]
  listedLeveragedVaults_contains: [String!]
  listedLeveragedVaults_contains_nocase: [String!]
  listedLeveragedVaults_not_contains: [String!]
  listedLeveragedVaults_not_contains_nocase: [String!]
  listedLeveragedVaults_: LeveragedVault_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVaultHistoricalValue_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  leveragedVaultMaturity: String
  leveragedVaultMaturity_not: String
  leveragedVaultMaturity_gt: String
  leveragedVaultMaturity_lt: String
  leveragedVaultMaturity_gte: String
  leveragedVaultMaturity_lte: String
  leveragedVaultMaturity_in: [String!]
  leveragedVaultMaturity_not_in: [String!]
  leveragedVaultMaturity_contains: String
  leveragedVaultMaturity_contains_nocase: String
  leveragedVaultMaturity_not_contains: String
  leveragedVaultMaturity_not_contains_nocase: String
  leveragedVaultMaturity_starts_with: String
  leveragedVaultMaturity_starts_with_nocase: String
  leveragedVaultMaturity_not_starts_with: String
  leveragedVaultMaturity_not_starts_with_nocase: String
  leveragedVaultMaturity_ends_with: String
  leveragedVaultMaturity_ends_with_nocase: String
  leveragedVaultMaturity_not_ends_with: String
  leveragedVaultMaturity_not_ends_with_nocase: String
  leveragedVaultMaturity_: LeveragedVaultMaturity_filter
  underlyingValueOfStrategyToken: BigInt
  underlyingValueOfStrategyToken_not: BigInt
  underlyingValueOfStrategyToken_gt: BigInt
  underlyingValueOfStrategyToken_lt: BigInt
  underlyingValueOfStrategyToken_gte: BigInt
  underlyingValueOfStrategyToken_lte: BigInt
  underlyingValueOfStrategyToken_in: [BigInt!]
  underlyingValueOfStrategyToken_not_in: [BigInt!]
  ethExchangeRate: String
  ethExchangeRate_not: String
  ethExchangeRate_gt: String
  ethExchangeRate_lt: String
  ethExchangeRate_gte: String
  ethExchangeRate_lte: String
  ethExchangeRate_in: [String!]
  ethExchangeRate_not_in: [String!]
  ethExchangeRate_contains: String
  ethExchangeRate_contains_nocase: String
  ethExchangeRate_not_contains: String
  ethExchangeRate_not_contains_nocase: String
  ethExchangeRate_starts_with: String
  ethExchangeRate_starts_with_nocase: String
  ethExchangeRate_not_starts_with: String
  ethExchangeRate_not_starts_with_nocase: String
  ethExchangeRate_ends_with: String
  ethExchangeRate_ends_with_nocase: String
  ethExchangeRate_not_ends_with: String
  ethExchangeRate_not_ends_with_nocase: String
  ethExchangeRate_: EthExchangeRateHistoricalData_filter
  assetExchangeRate: String
  assetExchangeRate_not: String
  assetExchangeRate_gt: String
  assetExchangeRate_lt: String
  assetExchangeRate_gte: String
  assetExchangeRate_lte: String
  assetExchangeRate_in: [String!]
  assetExchangeRate_not_in: [String!]
  assetExchangeRate_contains: String
  assetExchangeRate_contains_nocase: String
  assetExchangeRate_not_contains: String
  assetExchangeRate_not_contains_nocase: String
  assetExchangeRate_starts_with: String
  assetExchangeRate_starts_with_nocase: String
  assetExchangeRate_not_starts_with: String
  assetExchangeRate_not_starts_with_nocase: String
  assetExchangeRate_ends_with: String
  assetExchangeRate_ends_with_nocase: String
  assetExchangeRate_not_ends_with: String
  assetExchangeRate_not_ends_with_nocase: String
  assetExchangeRate_: AssetExchangeRateHistoricalData_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVaultMaturityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  leveragedVaultMaturity: String
  leveragedVaultMaturity_not: String
  leveragedVaultMaturity_gt: String
  leveragedVaultMaturity_lt: String
  leveragedVaultMaturity_gte: String
  leveragedVaultMaturity_lte: String
  leveragedVaultMaturity_in: [String!]
  leveragedVaultMaturity_not_in: [String!]
  leveragedVaultMaturity_contains: String
  leveragedVaultMaturity_contains_nocase: String
  leveragedVaultMaturity_not_contains: String
  leveragedVaultMaturity_not_contains_nocase: String
  leveragedVaultMaturity_starts_with: String
  leveragedVaultMaturity_starts_with_nocase: String
  leveragedVaultMaturity_not_starts_with: String
  leveragedVaultMaturity_not_starts_with_nocase: String
  leveragedVaultMaturity_ends_with: String
  leveragedVaultMaturity_ends_with_nocase: String
  leveragedVaultMaturity_not_ends_with: String
  leveragedVaultMaturity_not_ends_with_nocase: String
  leveragedVaultMaturity_: LeveragedVaultMaturity_filter
  netStrategyTokenChange: BigInt
  netStrategyTokenChange_not: BigInt
  netStrategyTokenChange_gt: BigInt
  netStrategyTokenChange_lt: BigInt
  netStrategyTokenChange_gte: BigInt
  netStrategyTokenChange_lte: BigInt
  netStrategyTokenChange_in: [BigInt!]
  netStrategyTokenChange_not_in: [BigInt!]
  netAssetCashChange: BigInt
  netAssetCashChange_not: BigInt
  netAssetCashChange_gt: BigInt
  netAssetCashChange_lt: BigInt
  netAssetCashChange_gte: BigInt
  netAssetCashChange_lte: BigInt
  netAssetCashChange_in: [BigInt!]
  netAssetCashChange_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVaultMaturity_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  leveragedVault: String
  leveragedVault_not: String
  leveragedVault_gt: String
  leveragedVault_lt: String
  leveragedVault_gte: String
  leveragedVault_lte: String
  leveragedVault_in: [String!]
  leveragedVault_not_in: [String!]
  leveragedVault_contains: String
  leveragedVault_contains_nocase: String
  leveragedVault_not_contains: String
  leveragedVault_not_contains_nocase: String
  leveragedVault_starts_with: String
  leveragedVault_starts_with_nocase: String
  leveragedVault_not_starts_with: String
  leveragedVault_not_starts_with_nocase: String
  leveragedVault_ends_with: String
  leveragedVault_ends_with_nocase: String
  leveragedVault_not_ends_with: String
  leveragedVault_not_ends_with_nocase: String
  leveragedVault_: LeveragedVault_filter
  maturity: Int
  maturity_not: Int
  maturity_gt: Int
  maturity_lt: Int
  maturity_gte: Int
  maturity_lte: Int
  maturity_in: [Int!]
  maturity_not_in: [Int!]
  totalPrimaryfCashBorrowed: BigInt
  totalPrimaryfCashBorrowed_not: BigInt
  totalPrimaryfCashBorrowed_gt: BigInt
  totalPrimaryfCashBorrowed_lt: BigInt
  totalPrimaryfCashBorrowed_gte: BigInt
  totalPrimaryfCashBorrowed_lte: BigInt
  totalPrimaryfCashBorrowed_in: [BigInt!]
  totalPrimaryfCashBorrowed_not_in: [BigInt!]
  totalAssetCash: BigInt
  totalAssetCash_not: BigInt
  totalAssetCash_gt: BigInt
  totalAssetCash_lt: BigInt
  totalAssetCash_gte: BigInt
  totalAssetCash_lte: BigInt
  totalAssetCash_in: [BigInt!]
  totalAssetCash_not_in: [BigInt!]
  totalVaultShares: BigInt
  totalVaultShares_not: BigInt
  totalVaultShares_gt: BigInt
  totalVaultShares_lt: BigInt
  totalVaultShares_gte: BigInt
  totalVaultShares_lte: BigInt
  totalVaultShares_in: [BigInt!]
  totalVaultShares_not_in: [BigInt!]
  totalStrategyTokens: BigInt
  totalStrategyTokens_not: BigInt
  totalStrategyTokens_gt: BigInt
  totalStrategyTokens_lt: BigInt
  totalStrategyTokens_gte: BigInt
  totalStrategyTokens_lte: BigInt
  totalStrategyTokens_in: [BigInt!]
  totalStrategyTokens_not_in: [BigInt!]
  totalSecondaryfCashBorrowed: [BigInt!]
  totalSecondaryfCashBorrowed_not: [BigInt!]
  totalSecondaryfCashBorrowed_contains: [BigInt!]
  totalSecondaryfCashBorrowed_contains_nocase: [BigInt!]
  totalSecondaryfCashBorrowed_not_contains: [BigInt!]
  totalSecondaryfCashBorrowed_not_contains_nocase: [BigInt!]
  totalSecondaryDebtShares: [BigInt!]
  totalSecondaryDebtShares_not: [BigInt!]
  totalSecondaryDebtShares_contains: [BigInt!]
  totalSecondaryDebtShares_contains_nocase: [BigInt!]
  totalSecondaryDebtShares_not_contains: [BigInt!]
  totalSecondaryDebtShares_not_contains_nocase: [BigInt!]
  totalReserveFeesAccrued: BigInt
  totalReserveFeesAccrued_not: BigInt
  totalReserveFeesAccrued_gt: BigInt
  totalReserveFeesAccrued_lt: BigInt
  totalReserveFeesAccrued_gte: BigInt
  totalReserveFeesAccrued_lte: BigInt
  totalReserveFeesAccrued_in: [BigInt!]
  totalReserveFeesAccrued_not_in: [BigInt!]
  totalNTokenFeesAccrued: BigInt
  totalNTokenFeesAccrued_not: BigInt
  totalNTokenFeesAccrued_gt: BigInt
  totalNTokenFeesAccrued_lt: BigInt
  totalNTokenFeesAccrued_gte: BigInt
  totalNTokenFeesAccrued_lte: BigInt
  totalNTokenFeesAccrued_in: [BigInt!]
  totalNTokenFeesAccrued_not_in: [BigInt!]
  isSettled: Boolean
  isSettled_not: Boolean
  isSettled_in: [Boolean!]
  isSettled_not_in: [Boolean!]
  settlementTimestamp: Int
  settlementTimestamp_not: Int
  settlementTimestamp_gt: Int
  settlementTimestamp_lt: Int
  settlementTimestamp_gte: Int
  settlementTimestamp_lte: Int
  settlementTimestamp_in: [Int!]
  settlementTimestamp_not_in: [Int!]
  settlementStrategyTokenValue: BigInt
  settlementStrategyTokenValue_not: BigInt
  settlementStrategyTokenValue_gt: BigInt
  settlementStrategyTokenValue_lt: BigInt
  settlementStrategyTokenValue_gte: BigInt
  settlementStrategyTokenValue_lte: BigInt
  settlementStrategyTokenValue_in: [BigInt!]
  settlementStrategyTokenValue_not_in: [BigInt!]
  settlementSecondaryBorrowfCashSnapshot: [BigInt!]
  settlementSecondaryBorrowfCashSnapshot_not: [BigInt!]
  settlementSecondaryBorrowfCashSnapshot_contains: [BigInt!]
  settlementSecondaryBorrowfCashSnapshot_contains_nocase: [BigInt!]
  settlementSecondaryBorrowfCashSnapshot_not_contains: [BigInt!]
  settlementSecondaryBorrowfCashSnapshot_not_contains_nocase: [BigInt!]
  settlementSecondaryBorrowExchangeRate: [BigInt!]
  settlementSecondaryBorrowExchangeRate_not: [BigInt!]
  settlementSecondaryBorrowExchangeRate_contains: [BigInt!]
  settlementSecondaryBorrowExchangeRate_contains_nocase: [BigInt!]
  settlementSecondaryBorrowExchangeRate_not_contains: [BigInt!]
  settlementSecondaryBorrowExchangeRate_not_contains_nocase: [BigInt!]
  settlementRate: String
  settlementRate_not: String
  settlementRate_gt: String
  settlementRate_lt: String
  settlementRate_gte: String
  settlementRate_lte: String
  settlementRate_in: [String!]
  settlementRate_not_in: [String!]
  settlementRate_contains: String
  settlementRate_contains_nocase: String
  settlementRate_not_contains: String
  settlementRate_not_contains_nocase: String
  settlementRate_starts_with: String
  settlementRate_starts_with_nocase: String
  settlementRate_not_starts_with: String
  settlementRate_not_starts_with_nocase: String
  settlementRate_ends_with: String
  settlementRate_ends_with_nocase: String
  settlementRate_not_ends_with: String
  settlementRate_not_ends_with_nocase: String
  settlementRate_: SettlementRate_filter
  shortfall: BigInt
  shortfall_not: BigInt
  shortfall_gt: BigInt
  shortfall_lt: BigInt
  shortfall_gte: BigInt
  shortfall_lte: BigInt
  shortfall_in: [BigInt!]
  shortfall_not_in: [BigInt!]
  insolvency: BigInt
  insolvency_not: BigInt
  insolvency_gt: BigInt
  insolvency_lt: BigInt
  insolvency_gte: BigInt
  insolvency_lte: BigInt
  insolvency_in: [BigInt!]
  insolvency_not_in: [BigInt!]
  remainingSettledAssetCash: BigInt
  remainingSettledAssetCash_not: BigInt
  remainingSettledAssetCash_gt: BigInt
  remainingSettledAssetCash_lt: BigInt
  remainingSettledAssetCash_gte: BigInt
  remainingSettledAssetCash_lte: BigInt
  remainingSettledAssetCash_in: [BigInt!]
  remainingSettledAssetCash_not_in: [BigInt!]
  remainingSettledStrategyTokens: BigInt
  remainingSettledStrategyTokens_not: BigInt
  remainingSettledStrategyTokens_gt: BigInt
  remainingSettledStrategyTokens_lt: BigInt
  remainingSettledStrategyTokens_gte: BigInt
  remainingSettledStrategyTokens_lte: BigInt
  remainingSettledStrategyTokens_in: [BigInt!]
  remainingSettledStrategyTokens_not_in: [BigInt!]
  accounts_: LeveragedVaultAccount_filter
  historicalValue_: LeveragedVaultHistoricalValue_filter
  events_: LeveragedVaultMaturityEvent_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVaultTrade_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  vaultTradeType: VaultTradeType
  vaultTradeType_not: VaultTradeType
  vaultTradeType_in: [VaultTradeType!]
  vaultTradeType_not_in: [VaultTradeType!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  leveragedVault: String
  leveragedVault_not: String
  leveragedVault_gt: String
  leveragedVault_lt: String
  leveragedVault_gte: String
  leveragedVault_lte: String
  leveragedVault_in: [String!]
  leveragedVault_not_in: [String!]
  leveragedVault_contains: String
  leveragedVault_contains_nocase: String
  leveragedVault_not_contains: String
  leveragedVault_not_contains_nocase: String
  leveragedVault_starts_with: String
  leveragedVault_starts_with_nocase: String
  leveragedVault_not_starts_with: String
  leveragedVault_not_starts_with_nocase: String
  leveragedVault_ends_with: String
  leveragedVault_ends_with_nocase: String
  leveragedVault_not_ends_with: String
  leveragedVault_not_ends_with_nocase: String
  leveragedVault_: LeveragedVault_filter
  leveragedVaultAccount: String
  leveragedVaultAccount_not: String
  leveragedVaultAccount_gt: String
  leveragedVaultAccount_lt: String
  leveragedVaultAccount_gte: String
  leveragedVaultAccount_lte: String
  leveragedVaultAccount_in: [String!]
  leveragedVaultAccount_not_in: [String!]
  leveragedVaultAccount_contains: String
  leveragedVaultAccount_contains_nocase: String
  leveragedVaultAccount_not_contains: String
  leveragedVaultAccount_not_contains_nocase: String
  leveragedVaultAccount_starts_with: String
  leveragedVaultAccount_starts_with_nocase: String
  leveragedVaultAccount_not_starts_with: String
  leveragedVaultAccount_not_starts_with_nocase: String
  leveragedVaultAccount_ends_with: String
  leveragedVaultAccount_ends_with_nocase: String
  leveragedVaultAccount_not_ends_with: String
  leveragedVaultAccount_not_ends_with_nocase: String
  leveragedVaultAccount_: LeveragedVaultAccount_filter
  leveragedVaultMaturityBefore: String
  leveragedVaultMaturityBefore_not: String
  leveragedVaultMaturityBefore_gt: String
  leveragedVaultMaturityBefore_lt: String
  leveragedVaultMaturityBefore_gte: String
  leveragedVaultMaturityBefore_lte: String
  leveragedVaultMaturityBefore_in: [String!]
  leveragedVaultMaturityBefore_not_in: [String!]
  leveragedVaultMaturityBefore_contains: String
  leveragedVaultMaturityBefore_contains_nocase: String
  leveragedVaultMaturityBefore_not_contains: String
  leveragedVaultMaturityBefore_not_contains_nocase: String
  leveragedVaultMaturityBefore_starts_with: String
  leveragedVaultMaturityBefore_starts_with_nocase: String
  leveragedVaultMaturityBefore_not_starts_with: String
  leveragedVaultMaturityBefore_not_starts_with_nocase: String
  leveragedVaultMaturityBefore_ends_with: String
  leveragedVaultMaturityBefore_ends_with_nocase: String
  leveragedVaultMaturityBefore_not_ends_with: String
  leveragedVaultMaturityBefore_not_ends_with_nocase: String
  leveragedVaultMaturityBefore_: LeveragedVaultMaturity_filter
  leveragedVaultMaturityAfter: String
  leveragedVaultMaturityAfter_not: String
  leveragedVaultMaturityAfter_gt: String
  leveragedVaultMaturityAfter_lt: String
  leveragedVaultMaturityAfter_gte: String
  leveragedVaultMaturityAfter_lte: String
  leveragedVaultMaturityAfter_in: [String!]
  leveragedVaultMaturityAfter_not_in: [String!]
  leveragedVaultMaturityAfter_contains: String
  leveragedVaultMaturityAfter_contains_nocase: String
  leveragedVaultMaturityAfter_not_contains: String
  leveragedVaultMaturityAfter_not_contains_nocase: String
  leveragedVaultMaturityAfter_starts_with: String
  leveragedVaultMaturityAfter_starts_with_nocase: String
  leveragedVaultMaturityAfter_not_starts_with: String
  leveragedVaultMaturityAfter_not_starts_with_nocase: String
  leveragedVaultMaturityAfter_ends_with: String
  leveragedVaultMaturityAfter_ends_with_nocase: String
  leveragedVaultMaturityAfter_not_ends_with: String
  leveragedVaultMaturityAfter_not_ends_with_nocase: String
  leveragedVaultMaturityAfter_: LeveragedVaultMaturity_filter
  primaryBorrowfCashBefore: BigInt
  primaryBorrowfCashBefore_not: BigInt
  primaryBorrowfCashBefore_gt: BigInt
  primaryBorrowfCashBefore_lt: BigInt
  primaryBorrowfCashBefore_gte: BigInt
  primaryBorrowfCashBefore_lte: BigInt
  primaryBorrowfCashBefore_in: [BigInt!]
  primaryBorrowfCashBefore_not_in: [BigInt!]
  primaryBorrowfCashAfter: BigInt
  primaryBorrowfCashAfter_not: BigInt
  primaryBorrowfCashAfter_gt: BigInt
  primaryBorrowfCashAfter_lt: BigInt
  primaryBorrowfCashAfter_gte: BigInt
  primaryBorrowfCashAfter_lte: BigInt
  primaryBorrowfCashAfter_in: [BigInt!]
  primaryBorrowfCashAfter_not_in: [BigInt!]
  netPrimaryBorrowfCashChange: BigInt
  netPrimaryBorrowfCashChange_not: BigInt
  netPrimaryBorrowfCashChange_gt: BigInt
  netPrimaryBorrowfCashChange_lt: BigInt
  netPrimaryBorrowfCashChange_gte: BigInt
  netPrimaryBorrowfCashChange_lte: BigInt
  netPrimaryBorrowfCashChange_in: [BigInt!]
  netPrimaryBorrowfCashChange_not_in: [BigInt!]
  vaultSharesBefore: BigInt
  vaultSharesBefore_not: BigInt
  vaultSharesBefore_gt: BigInt
  vaultSharesBefore_lt: BigInt
  vaultSharesBefore_gte: BigInt
  vaultSharesBefore_lte: BigInt
  vaultSharesBefore_in: [BigInt!]
  vaultSharesBefore_not_in: [BigInt!]
  vaultSharesAfter: BigInt
  vaultSharesAfter_not: BigInt
  vaultSharesAfter_gt: BigInt
  vaultSharesAfter_lt: BigInt
  vaultSharesAfter_gte: BigInt
  vaultSharesAfter_lte: BigInt
  vaultSharesAfter_in: [BigInt!]
  vaultSharesAfter_not_in: [BigInt!]
  netVaultSharesChange: BigInt
  netVaultSharesChange_not: BigInt
  netVaultSharesChange_gt: BigInt
  netVaultSharesChange_lt: BigInt
  netVaultSharesChange_gte: BigInt
  netVaultSharesChange_lte: BigInt
  netVaultSharesChange_in: [BigInt!]
  netVaultSharesChange_not_in: [BigInt!]
  secondaryDebtSharesBefore: [BigInt!]
  secondaryDebtSharesBefore_not: [BigInt!]
  secondaryDebtSharesBefore_contains: [BigInt!]
  secondaryDebtSharesBefore_contains_nocase: [BigInt!]
  secondaryDebtSharesBefore_not_contains: [BigInt!]
  secondaryDebtSharesBefore_not_contains_nocase: [BigInt!]
  secondaryDebtSharesAfter: [BigInt!]
  secondaryDebtSharesAfter_not: [BigInt!]
  secondaryDebtSharesAfter_contains: [BigInt!]
  secondaryDebtSharesAfter_contains_nocase: [BigInt!]
  secondaryDebtSharesAfter_not_contains: [BigInt!]
  secondaryDebtSharesAfter_not_contains_nocase: [BigInt!]
  netSecondaryDebtSharesChange: [BigInt!]
  netSecondaryDebtSharesChange_not: [BigInt!]
  netSecondaryDebtSharesChange_contains: [BigInt!]
  netSecondaryDebtSharesChange_contains_nocase: [BigInt!]
  netSecondaryDebtSharesChange_not_contains: [BigInt!]
  netSecondaryDebtSharesChange_not_contains_nocase: [BigInt!]
  netUnderlyingCash: BigInt
  netUnderlyingCash_not: BigInt
  netUnderlyingCash_gt: BigInt
  netUnderlyingCash_lt: BigInt
  netUnderlyingCash_gte: BigInt
  netUnderlyingCash_lte: BigInt
  netUnderlyingCash_in: [BigInt!]
  netUnderlyingCash_not_in: [BigInt!]
  netBorrowedUnderlying: BigInt
  netBorrowedUnderlying_not: BigInt
  netBorrowedUnderlying_gt: BigInt
  netBorrowedUnderlying_lt: BigInt
  netBorrowedUnderlying_gte: BigInt
  netBorrowedUnderlying_lte: BigInt
  netBorrowedUnderlying_in: [BigInt!]
  netBorrowedUnderlying_not_in: [BigInt!]
  netDepositUnderlying: BigInt
  netDepositUnderlying_not: BigInt
  netDepositUnderlying_gt: BigInt
  netDepositUnderlying_lt: BigInt
  netDepositUnderlying_gte: BigInt
  netDepositUnderlying_lte: BigInt
  netDepositUnderlying_in: [BigInt!]
  netDepositUnderlying_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input LeveragedVault_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  vaultAddress: Bytes
  vaultAddress_not: Bytes
  vaultAddress_in: [Bytes!]
  vaultAddress_not_in: [Bytes!]
  vaultAddress_contains: Bytes
  vaultAddress_not_contains: Bytes
  strategy: Bytes
  strategy_not: Bytes
  strategy_in: [Bytes!]
  strategy_not_in: [Bytes!]
  strategy_contains: Bytes
  strategy_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  primaryBorrowCurrency: String
  primaryBorrowCurrency_not: String
  primaryBorrowCurrency_gt: String
  primaryBorrowCurrency_lt: String
  primaryBorrowCurrency_gte: String
  primaryBorrowCurrency_lte: String
  primaryBorrowCurrency_in: [String!]
  primaryBorrowCurrency_not_in: [String!]
  primaryBorrowCurrency_contains: String
  primaryBorrowCurrency_contains_nocase: String
  primaryBorrowCurrency_not_contains: String
  primaryBorrowCurrency_not_contains_nocase: String
  primaryBorrowCurrency_starts_with: String
  primaryBorrowCurrency_starts_with_nocase: String
  primaryBorrowCurrency_not_starts_with: String
  primaryBorrowCurrency_not_starts_with_nocase: String
  primaryBorrowCurrency_ends_with: String
  primaryBorrowCurrency_ends_with_nocase: String
  primaryBorrowCurrency_not_ends_with: String
  primaryBorrowCurrency_not_ends_with_nocase: String
  primaryBorrowCurrency_: Currency_filter
  minAccountBorrowSize: BigInt
  minAccountBorrowSize_not: BigInt
  minAccountBorrowSize_gt: BigInt
  minAccountBorrowSize_lt: BigInt
  minAccountBorrowSize_gte: BigInt
  minAccountBorrowSize_lte: BigInt
  minAccountBorrowSize_in: [BigInt!]
  minAccountBorrowSize_not_in: [BigInt!]
  minCollateralRatioBasisPoints: Int
  minCollateralRatioBasisPoints_not: Int
  minCollateralRatioBasisPoints_gt: Int
  minCollateralRatioBasisPoints_lt: Int
  minCollateralRatioBasisPoints_gte: Int
  minCollateralRatioBasisPoints_lte: Int
  minCollateralRatioBasisPoints_in: [Int!]
  minCollateralRatioBasisPoints_not_in: [Int!]
  maxDeleverageCollateralRatioBasisPoints: Int
  maxDeleverageCollateralRatioBasisPoints_not: Int
  maxDeleverageCollateralRatioBasisPoints_gt: Int
  maxDeleverageCollateralRatioBasisPoints_lt: Int
  maxDeleverageCollateralRatioBasisPoints_gte: Int
  maxDeleverageCollateralRatioBasisPoints_lte: Int
  maxDeleverageCollateralRatioBasisPoints_in: [Int!]
  maxDeleverageCollateralRatioBasisPoints_not_in: [Int!]
  feeRateBasisPoints: Int
  feeRateBasisPoints_not: Int
  feeRateBasisPoints_gt: Int
  feeRateBasisPoints_lt: Int
  feeRateBasisPoints_gte: Int
  feeRateBasisPoints_lte: Int
  feeRateBasisPoints_in: [Int!]
  feeRateBasisPoints_not_in: [Int!]
  reserveFeeSharePercent: Int
  reserveFeeSharePercent_not: Int
  reserveFeeSharePercent_gt: Int
  reserveFeeSharePercent_lt: Int
  reserveFeeSharePercent_gte: Int
  reserveFeeSharePercent_lte: Int
  reserveFeeSharePercent_in: [Int!]
  reserveFeeSharePercent_not_in: [Int!]
  liquidationRatePercent: Int
  liquidationRatePercent_not: Int
  liquidationRatePercent_gt: Int
  liquidationRatePercent_lt: Int
  liquidationRatePercent_gte: Int
  liquidationRatePercent_lte: Int
  liquidationRatePercent_in: [Int!]
  liquidationRatePercent_not_in: [Int!]
  maxBorrowMarketIndex: Int
  maxBorrowMarketIndex_not: Int
  maxBorrowMarketIndex_gt: Int
  maxBorrowMarketIndex_lt: Int
  maxBorrowMarketIndex_gte: Int
  maxBorrowMarketIndex_lte: Int
  maxBorrowMarketIndex_in: [Int!]
  maxBorrowMarketIndex_not_in: [Int!]
  secondaryBorrowCurrencies: [String!]
  secondaryBorrowCurrencies_not: [String!]
  secondaryBorrowCurrencies_contains: [String!]
  secondaryBorrowCurrencies_contains_nocase: [String!]
  secondaryBorrowCurrencies_not_contains: [String!]
  secondaryBorrowCurrencies_not_contains_nocase: [String!]
  secondaryBorrowCurrencies_: Currency_filter
  maxRequiredAccountCollateralRatioBasisPoints: Int
  maxRequiredAccountCollateralRatioBasisPoints_not: Int
  maxRequiredAccountCollateralRatioBasisPoints_gt: Int
  maxRequiredAccountCollateralRatioBasisPoints_lt: Int
  maxRequiredAccountCollateralRatioBasisPoints_gte: Int
  maxRequiredAccountCollateralRatioBasisPoints_lte: Int
  maxRequiredAccountCollateralRatioBasisPoints_in: [Int!]
  maxRequiredAccountCollateralRatioBasisPoints_not_in: [Int!]
  enabled: Boolean
  enabled_not: Boolean
  enabled_in: [Boolean!]
  enabled_not_in: [Boolean!]
  allowRollPosition: Boolean
  allowRollPosition_not: Boolean
  allowRollPosition_in: [Boolean!]
  allowRollPosition_not_in: [Boolean!]
  onlyVaultEntry: Boolean
  onlyVaultEntry_not: Boolean
  onlyVaultEntry_in: [Boolean!]
  onlyVaultEntry_not_in: [Boolean!]
  onlyVaultExit: Boolean
  onlyVaultExit_not: Boolean
  onlyVaultExit_in: [Boolean!]
  onlyVaultExit_not_in: [Boolean!]
  onlyVaultRoll: Boolean
  onlyVaultRoll_not: Boolean
  onlyVaultRoll_in: [Boolean!]
  onlyVaultRoll_not_in: [Boolean!]
  onlyVaultDeleverage: Boolean
  onlyVaultDeleverage_not: Boolean
  onlyVaultDeleverage_in: [Boolean!]
  onlyVaultDeleverage_not_in: [Boolean!]
  onlyVaultSettle: Boolean
  onlyVaultSettle_not: Boolean
  onlyVaultSettle_in: [Boolean!]
  onlyVaultSettle_not_in: [Boolean!]
  allowsReentrancy: Boolean
  allowsReentrancy_not: Boolean
  allowsReentrancy_in: [Boolean!]
  allowsReentrancy_not_in: [Boolean!]
  deleverageDisabled: Boolean
  deleverageDisabled_not: Boolean
  deleverageDisabled_in: [Boolean!]
  deleverageDisabled_not_in: [Boolean!]
  maturities_: LeveragedVaultMaturity_filter
  vaultCapacity_: LeveragedVaultCapacity_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Liquidation_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  type: LiquidationType
  type_not: LiquidationType
  type_in: [LiquidationType!]
  type_not_in: [LiquidationType!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  liquidator: String
  liquidator_not: String
  liquidator_gt: String
  liquidator_lt: String
  liquidator_gte: String
  liquidator_lte: String
  liquidator_in: [String!]
  liquidator_not_in: [String!]
  liquidator_contains: String
  liquidator_contains_nocase: String
  liquidator_not_contains: String
  liquidator_not_contains_nocase: String
  liquidator_starts_with: String
  liquidator_starts_with_nocase: String
  liquidator_not_starts_with: String
  liquidator_not_starts_with_nocase: String
  liquidator_ends_with: String
  liquidator_ends_with_nocase: String
  liquidator_not_ends_with: String
  liquidator_not_ends_with_nocase: String
  liquidator_: Account_filter
  localCurrency: String
  localCurrency_not: String
  localCurrency_gt: String
  localCurrency_lt: String
  localCurrency_gte: String
  localCurrency_lte: String
  localCurrency_in: [String!]
  localCurrency_not_in: [String!]
  localCurrency_contains: String
  localCurrency_contains_nocase: String
  localCurrency_not_contains: String
  localCurrency_not_contains_nocase: String
  localCurrency_starts_with: String
  localCurrency_starts_with_nocase: String
  localCurrency_not_starts_with: String
  localCurrency_not_starts_with_nocase: String
  localCurrency_ends_with: String
  localCurrency_ends_with_nocase: String
  localCurrency_not_ends_with: String
  localCurrency_not_ends_with_nocase: String
  localCurrency_: Currency_filter
  netLocalFromLiquidator: BigInt
  netLocalFromLiquidator_not: BigInt
  netLocalFromLiquidator_gt: BigInt
  netLocalFromLiquidator_lt: BigInt
  netLocalFromLiquidator_gte: BigInt
  netLocalFromLiquidator_lte: BigInt
  netLocalFromLiquidator_in: [BigInt!]
  netLocalFromLiquidator_not_in: [BigInt!]
  collateralOrFcashCurrency: String
  collateralOrFcashCurrency_not: String
  collateralOrFcashCurrency_gt: String
  collateralOrFcashCurrency_lt: String
  collateralOrFcashCurrency_gte: String
  collateralOrFcashCurrency_lte: String
  collateralOrFcashCurrency_in: [String!]
  collateralOrFcashCurrency_not_in: [String!]
  collateralOrFcashCurrency_contains: String
  collateralOrFcashCurrency_contains_nocase: String
  collateralOrFcashCurrency_not_contains: String
  collateralOrFcashCurrency_not_contains_nocase: String
  collateralOrFcashCurrency_starts_with: String
  collateralOrFcashCurrency_starts_with_nocase: String
  collateralOrFcashCurrency_not_starts_with: String
  collateralOrFcashCurrency_not_starts_with_nocase: String
  collateralOrFcashCurrency_ends_with: String
  collateralOrFcashCurrency_ends_with_nocase: String
  collateralOrFcashCurrency_not_ends_with: String
  collateralOrFcashCurrency_not_ends_with_nocase: String
  collateralOrFcashCurrency_: Currency_filter
  netCollateralTransfer: BigInt
  netCollateralTransfer_not: BigInt
  netCollateralTransfer_gt: BigInt
  netCollateralTransfer_lt: BigInt
  netCollateralTransfer_gte: BigInt
  netCollateralTransfer_lte: BigInt
  netCollateralTransfer_in: [BigInt!]
  netCollateralTransfer_not_in: [BigInt!]
  netNTokenTransfer: BigInt
  netNTokenTransfer_not: BigInt
  netNTokenTransfer_gt: BigInt
  netNTokenTransfer_lt: BigInt
  netNTokenTransfer_gte: BigInt
  netNTokenTransfer_lte: BigInt
  netNTokenTransfer_in: [BigInt!]
  netNTokenTransfer_not_in: [BigInt!]
  fCashMaturities: [BigInt!]
  fCashMaturities_not: [BigInt!]
  fCashMaturities_contains: [BigInt!]
  fCashMaturities_contains_nocase: [BigInt!]
  fCashMaturities_not_contains: [BigInt!]
  fCashMaturities_not_contains_nocase: [BigInt!]
  fCashNotionalTransfer: [BigInt!]
  fCashNotionalTransfer_not: [BigInt!]
  fCashNotionalTransfer_contains: [BigInt!]
  fCashNotionalTransfer_contains_nocase: [BigInt!]
  fCashNotionalTransfer_not_contains: [BigInt!]
  fCashNotionalTransfer_not_contains_nocase: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input MarketHistoricalData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter
  totalfCash: BigInt
  totalfCash_not: BigInt
  totalfCash_gt: BigInt
  totalfCash_lt: BigInt
  totalfCash_gte: BigInt
  totalfCash_lte: BigInt
  totalfCash_in: [BigInt!]
  totalfCash_not_in: [BigInt!]
  totalAssetCash: BigInt
  totalAssetCash_not: BigInt
  totalAssetCash_gt: BigInt
  totalAssetCash_lt: BigInt
  totalAssetCash_gte: BigInt
  totalAssetCash_lte: BigInt
  totalAssetCash_in: [BigInt!]
  totalAssetCash_not_in: [BigInt!]
  totalLiquidity: BigInt
  totalLiquidity_not: BigInt
  totalLiquidity_gt: BigInt
  totalLiquidity_lt: BigInt
  totalLiquidity_gte: BigInt
  totalLiquidity_lte: BigInt
  totalLiquidity_in: [BigInt!]
  totalLiquidity_not_in: [BigInt!]
  lastImpliedRate: Int
  lastImpliedRate_not: Int
  lastImpliedRate_gt: Int
  lastImpliedRate_lt: Int
  lastImpliedRate_gte: Int
  lastImpliedRate_lte: Int
  lastImpliedRate_in: [Int!]
  lastImpliedRate_not_in: [Int!]
  oracleRate: Int
  oracleRate_not: Int
  oracleRate_gt: Int
  oracleRate_lt: Int
  oracleRate_gte: Int
  oracleRate_lte: Int
  oracleRate_in: [Int!]
  oracleRate_not_in: [Int!]
  previousTradeTime: Int
  previousTradeTime_not: Int
  previousTradeTime_gt: Int
  previousTradeTime_lt: Int
  previousTradeTime_gte: Int
  previousTradeTime_lte: Int
  previousTradeTime_in: [Int!]
  previousTradeTime_not_in: [Int!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input MarketInitialization_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  markets: [String!]
  markets_not: [String!]
  markets_contains: [String!]
  markets_contains_nocase: [String!]
  markets_not_contains: [String!]
  markets_not_contains_nocase: [String!]
  markets_: Market_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Market_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  maturity: Int
  maturity_not: Int
  maturity_gt: Int
  maturity_lt: Int
  maturity_gte: Int
  maturity_lte: Int
  maturity_in: [Int!]
  maturity_not_in: [Int!]
  settlementDate: Int
  settlementDate_not: Int
  settlementDate_gt: Int
  settlementDate_lt: Int
  settlementDate_gte: Int
  settlementDate_lte: Int
  settlementDate_in: [Int!]
  settlementDate_not_in: [Int!]
  marketIndex: Int
  marketIndex_not: Int
  marketIndex_gt: Int
  marketIndex_lt: Int
  marketIndex_gte: Int
  marketIndex_lte: Int
  marketIndex_in: [Int!]
  marketIndex_not_in: [Int!]
  marketMaturityLengthSeconds: Int
  marketMaturityLengthSeconds_not: Int
  marketMaturityLengthSeconds_gt: Int
  marketMaturityLengthSeconds_lt: Int
  marketMaturityLengthSeconds_gte: Int
  marketMaturityLengthSeconds_lte: Int
  marketMaturityLengthSeconds_in: [Int!]
  marketMaturityLengthSeconds_not_in: [Int!]
  totalfCash: BigInt
  totalfCash_not: BigInt
  totalfCash_gt: BigInt
  totalfCash_lt: BigInt
  totalfCash_gte: BigInt
  totalfCash_lte: BigInt
  totalfCash_in: [BigInt!]
  totalfCash_not_in: [BigInt!]
  totalAssetCash: BigInt
  totalAssetCash_not: BigInt
  totalAssetCash_gt: BigInt
  totalAssetCash_lt: BigInt
  totalAssetCash_gte: BigInt
  totalAssetCash_lte: BigInt
  totalAssetCash_in: [BigInt!]
  totalAssetCash_not_in: [BigInt!]
  totalLiquidity: BigInt
  totalLiquidity_not: BigInt
  totalLiquidity_gt: BigInt
  totalLiquidity_lt: BigInt
  totalLiquidity_gte: BigInt
  totalLiquidity_lte: BigInt
  totalLiquidity_in: [BigInt!]
  totalLiquidity_not_in: [BigInt!]
  lastImpliedRate: Int
  lastImpliedRate_not: Int
  lastImpliedRate_gt: Int
  lastImpliedRate_lt: Int
  lastImpliedRate_gte: Int
  lastImpliedRate_lte: Int
  lastImpliedRate_in: [Int!]
  lastImpliedRate_not_in: [Int!]
  oracleRate: Int
  oracleRate_not: Int
  oracleRate_gt: Int
  oracleRate_lt: Int
  oracleRate_gte: Int
  oracleRate_lte: Int
  oracleRate_in: [Int!]
  oracleRate_not_in: [Int!]
  previousTradeTime: Int
  previousTradeTime_not: Int
  previousTradeTime_gt: Int
  previousTradeTime_lt: Int
  previousTradeTime_gte: Int
  previousTradeTime_lte: Int
  previousTradeTime_in: [Int!]
  previousTradeTime_not_in: [Int!]
  historicalData_: MarketHistoricalData_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input NTokenPresentValueHistoricalData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  pvAsset: BigInt
  pvAsset_not: BigInt
  pvAsset_gt: BigInt
  pvAsset_lt: BigInt
  pvAsset_gte: BigInt
  pvAsset_lte: BigInt
  pvAsset_in: [BigInt!]
  pvAsset_not_in: [BigInt!]
  pvUnderlying: BigInt
  pvUnderlying_not: BigInt
  pvUnderlying_gt: BigInt
  pvUnderlying_lt: BigInt
  pvUnderlying_gte: BigInt
  pvUnderlying_lte: BigInt
  pvUnderlying_in: [BigInt!]
  pvUnderlying_not_in: [BigInt!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input NoteBalanceChange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  noteBalance: String
  noteBalance_not: String
  noteBalance_gt: String
  noteBalance_lt: String
  noteBalance_gte: String
  noteBalance_lte: String
  noteBalance_in: [String!]
  noteBalance_not_in: [String!]
  noteBalance_contains: String
  noteBalance_contains_nocase: String
  noteBalance_not_contains: String
  noteBalance_not_contains_nocase: String
  noteBalance_starts_with: String
  noteBalance_starts_with_nocase: String
  noteBalance_not_starts_with: String
  noteBalance_not_starts_with_nocase: String
  noteBalance_ends_with: String
  noteBalance_ends_with_nocase: String
  noteBalance_not_ends_with: String
  noteBalance_not_ends_with_nocase: String
  noteBalance_: NoteBalance_filter
  noteBalanceBefore: BigInt
  noteBalanceBefore_not: BigInt
  noteBalanceBefore_gt: BigInt
  noteBalanceBefore_lt: BigInt
  noteBalanceBefore_gte: BigInt
  noteBalanceBefore_lte: BigInt
  noteBalanceBefore_in: [BigInt!]
  noteBalanceBefore_not_in: [BigInt!]
  noteBalanceAfter: BigInt
  noteBalanceAfter_not: BigInt
  noteBalanceAfter_gt: BigInt
  noteBalanceAfter_lt: BigInt
  noteBalanceAfter_gte: BigInt
  noteBalanceAfter_lte: BigInt
  noteBalanceAfter_in: [BigInt!]
  noteBalanceAfter_not_in: [BigInt!]
  sender: Bytes
  sender_not: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  receiver: Bytes
  receiver_not: Bytes
  receiver_in: [Bytes!]
  receiver_not_in: [Bytes!]
  receiver_contains: Bytes
  receiver_not_contains: Bytes
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input NoteBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Delegate_filter
  noteBalance: BigInt
  noteBalance_not: BigInt
  noteBalance_gt: BigInt
  noteBalance_lt: BigInt
  noteBalance_gte: BigInt
  noteBalance_lte: BigInt
  noteBalance_in: [BigInt!]
  noteBalance_not_in: [BigInt!]
  noteBalanceChanges_: NoteBalanceChange_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input ProposalState_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  state: ProposalStateEnum
  state_not: ProposalStateEnum
  state_in: [ProposalStateEnum!]
  state_not_in: [ProposalStateEnum!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Proposal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  createdAt: Int
  createdAt_not: Int
  createdAt_gt: Int
  createdAt_lt: Int
  createdAt_gte: Int
  createdAt_lte: Int
  createdAt_in: [Int!]
  createdAt_not_in: [Int!]
  proposer: String
  proposer_not: String
  proposer_gt: String
  proposer_lt: String
  proposer_gte: String
  proposer_lte: String
  proposer_in: [String!]
  proposer_not_in: [String!]
  proposer_contains: String
  proposer_contains_nocase: String
  proposer_not_contains: String
  proposer_not_contains_nocase: String
  proposer_starts_with: String
  proposer_starts_with_nocase: String
  proposer_not_starts_with: String
  proposer_not_starts_with_nocase: String
  proposer_ends_with: String
  proposer_ends_with_nocase: String
  proposer_not_ends_with: String
  proposer_not_ends_with_nocase: String
  proposer_: Delegate_filter
  votes: [String!]
  votes_not: [String!]
  votes_contains: [String!]
  votes_contains_nocase: [String!]
  votes_not_contains: [String!]
  votes_not_contains_nocase: [String!]
  votes_: Vote_filter
  history: [String!]
  history_not: [String!]
  history_contains: [String!]
  history_contains_nocase: [String!]
  history_not_contains: [String!]
  history_not_contains_nocase: [String!]
  history_: ProposalState_filter
  targets: [Bytes!]
  targets_not: [Bytes!]
  targets_contains: [Bytes!]
  targets_contains_nocase: [Bytes!]
  targets_not_contains: [Bytes!]
  targets_not_contains_nocase: [Bytes!]
  values: [BigInt!]
  values_not: [BigInt!]
  values_contains: [BigInt!]
  values_contains_nocase: [BigInt!]
  values_not_contains: [BigInt!]
  values_not_contains_nocase: [BigInt!]
  calldatas: [Bytes!]
  calldatas_not: [Bytes!]
  calldatas_contains: [Bytes!]
  calldatas_contains_nocase: [Bytes!]
  calldatas_not_contains: [Bytes!]
  calldatas_not_contains_nocase: [Bytes!]
  startBlock: Int
  startBlock_not: Int
  startBlock_gt: Int
  startBlock_lt: Int
  startBlock_gte: Int
  startBlock_lte: Int
  startBlock_in: [Int!]
  startBlock_not_in: [Int!]
  endBlock: Int
  endBlock_not: Int
  endBlock_gt: Int
  endBlock_lt: Int
  endBlock_gte: Int
  endBlock_lte: Int
  endBlock_in: [Int!]
  endBlock_not_in: [Int!]
  isCancelled: Boolean
  isCancelled_not: Boolean
  isCancelled_in: [Boolean!]
  isCancelled_not_in: [Boolean!]
  isQueued: Boolean
  isQueued_not: Boolean
  isQueued_in: [Boolean!]
  isQueued_not_in: [Boolean!]
  isExecuted: Boolean
  isExecuted_not: Boolean
  isExecuted_in: [Boolean!]
  isExecuted_not_in: [Boolean!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input SecondaryIncentiveRewarder_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  nToken: String
  nToken_not: String
  nToken_gt: String
  nToken_lt: String
  nToken_gte: String
  nToken_lte: String
  nToken_in: [String!]
  nToken_not_in: [String!]
  nToken_contains: String
  nToken_contains_nocase: String
  nToken_not_contains: String
  nToken_not_contains_nocase: String
  nToken_starts_with: String
  nToken_starts_with_nocase: String
  nToken_not_starts_with: String
  nToken_not_starts_with_nocase: String
  nToken_ends_with: String
  nToken_ends_with_nocase: String
  nToken_not_ends_with: String
  nToken_not_ends_with_nocase: String
  nToken_: nToken_filter
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input SettlementRate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  assetExchangeRate: String
  assetExchangeRate_not: String
  assetExchangeRate_gt: String
  assetExchangeRate_lt: String
  assetExchangeRate_gte: String
  assetExchangeRate_lte: String
  assetExchangeRate_in: [String!]
  assetExchangeRate_not_in: [String!]
  assetExchangeRate_contains: String
  assetExchangeRate_contains_nocase: String
  assetExchangeRate_not_contains: String
  assetExchangeRate_not_contains_nocase: String
  assetExchangeRate_starts_with: String
  assetExchangeRate_starts_with_nocase: String
  assetExchangeRate_not_starts_with: String
  assetExchangeRate_not_starts_with_nocase: String
  assetExchangeRate_ends_with: String
  assetExchangeRate_ends_with_nocase: String
  assetExchangeRate_not_ends_with: String
  assetExchangeRate_not_ends_with_nocase: String
  assetExchangeRate_: AssetExchangeRate_filter
  maturity: Int
  maturity_not: Int
  maturity_gt: Int
  maturity_lt: Int
  maturity_gte: Int
  maturity_lte: Int
  maturity_in: [Int!]
  maturity_not_in: [Int!]
  rate: BigInt
  rate_not: BigInt
  rate_gt: BigInt
  rate_lt: BigInt
  rate_gte: BigInt
  rate_lte: BigInt
  rate_in: [BigInt!]
  rate_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input StakedNoteBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Delegate_filter
  sNOTEBalance: BigInt
  sNOTEBalance_not: BigInt
  sNOTEBalance_gt: BigInt
  sNOTEBalance_lt: BigInt
  sNOTEBalance_gte: BigInt
  sNOTEBalance_lte: BigInt
  sNOTEBalance_in: [BigInt!]
  sNOTEBalance_not_in: [BigInt!]
  ethAmountJoined: BigInt
  ethAmountJoined_not: BigInt
  ethAmountJoined_gt: BigInt
  ethAmountJoined_lt: BigInt
  ethAmountJoined_gte: BigInt
  ethAmountJoined_lte: BigInt
  ethAmountJoined_in: [BigInt!]
  ethAmountJoined_not_in: [BigInt!]
  noteAmountJoined: BigInt
  noteAmountJoined_not: BigInt
  noteAmountJoined_gt: BigInt
  noteAmountJoined_lt: BigInt
  noteAmountJoined_gte: BigInt
  noteAmountJoined_lte: BigInt
  noteAmountJoined_in: [BigInt!]
  noteAmountJoined_not_in: [BigInt!]
  ethAmountRedeemed: BigInt
  ethAmountRedeemed_not: BigInt
  ethAmountRedeemed_gt: BigInt
  ethAmountRedeemed_lt: BigInt
  ethAmountRedeemed_gte: BigInt
  ethAmountRedeemed_lte: BigInt
  ethAmountRedeemed_in: [BigInt!]
  ethAmountRedeemed_not_in: [BigInt!]
  noteAmountRedeemed: BigInt
  noteAmountRedeemed_not: BigInt
  noteAmountRedeemed_gt: BigInt
  noteAmountRedeemed_lt: BigInt
  noteAmountRedeemed_gte: BigInt
  noteAmountRedeemed_lte: BigInt
  noteAmountRedeemed_in: [BigInt!]
  noteAmountRedeemed_not_in: [BigInt!]
  currentCoolDown: String
  currentCoolDown_not: String
  currentCoolDown_gt: String
  currentCoolDown_lt: String
  currentCoolDown_gte: String
  currentCoolDown_lte: String
  currentCoolDown_in: [String!]
  currentCoolDown_not_in: [String!]
  currentCoolDown_contains: String
  currentCoolDown_contains_nocase: String
  currentCoolDown_not_contains: String
  currentCoolDown_not_contains_nocase: String
  currentCoolDown_starts_with: String
  currentCoolDown_starts_with_nocase: String
  currentCoolDown_not_starts_with: String
  currentCoolDown_not_starts_with_nocase: String
  currentCoolDown_ends_with: String
  currentCoolDown_ends_with_nocase: String
  currentCoolDown_not_ends_with: String
  currentCoolDown_not_ends_with_nocase: String
  currentCoolDown_: StakedNoteCoolDown_filter
  coolDowns_: StakedNoteCoolDown_filter
  stakedNoteChanges_: StakedNoteChange_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input StakedNoteChange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  stakedNoteBalance: String
  stakedNoteBalance_not: String
  stakedNoteBalance_gt: String
  stakedNoteBalance_lt: String
  stakedNoteBalance_gte: String
  stakedNoteBalance_lte: String
  stakedNoteBalance_in: [String!]
  stakedNoteBalance_not_in: [String!]
  stakedNoteBalance_contains: String
  stakedNoteBalance_contains_nocase: String
  stakedNoteBalance_not_contains: String
  stakedNoteBalance_not_contains_nocase: String
  stakedNoteBalance_starts_with: String
  stakedNoteBalance_starts_with_nocase: String
  stakedNoteBalance_not_starts_with: String
  stakedNoteBalance_not_starts_with_nocase: String
  stakedNoteBalance_ends_with: String
  stakedNoteBalance_ends_with_nocase: String
  stakedNoteBalance_not_ends_with: String
  stakedNoteBalance_not_ends_with_nocase: String
  stakedNoteBalance_: StakedNoteBalance_filter
  sNOTEChangeType: sNOTEChangeType
  sNOTEChangeType_not: sNOTEChangeType
  sNOTEChangeType_in: [sNOTEChangeType!]
  sNOTEChangeType_not_in: [sNOTEChangeType!]
  sNOTEAmountBefore: BigInt
  sNOTEAmountBefore_not: BigInt
  sNOTEAmountBefore_gt: BigInt
  sNOTEAmountBefore_lt: BigInt
  sNOTEAmountBefore_gte: BigInt
  sNOTEAmountBefore_lte: BigInt
  sNOTEAmountBefore_in: [BigInt!]
  sNOTEAmountBefore_not_in: [BigInt!]
  sNOTEAmountAfter: BigInt
  sNOTEAmountAfter_not: BigInt
  sNOTEAmountAfter_gt: BigInt
  sNOTEAmountAfter_lt: BigInt
  sNOTEAmountAfter_gte: BigInt
  sNOTEAmountAfter_lte: BigInt
  sNOTEAmountAfter_in: [BigInt!]
  sNOTEAmountAfter_not_in: [BigInt!]
  ethAmountChange: BigInt
  ethAmountChange_not: BigInt
  ethAmountChange_gt: BigInt
  ethAmountChange_lt: BigInt
  ethAmountChange_gte: BigInt
  ethAmountChange_lte: BigInt
  ethAmountChange_in: [BigInt!]
  ethAmountChange_not_in: [BigInt!]
  noteAmountChange: BigInt
  noteAmountChange_not: BigInt
  noteAmountChange_gt: BigInt
  noteAmountChange_lt: BigInt
  noteAmountChange_gte: BigInt
  noteAmountChange_lte: BigInt
  noteAmountChange_in: [BigInt!]
  noteAmountChange_not_in: [BigInt!]
  bptAmountChange: BigInt
  bptAmountChange_not: BigInt
  bptAmountChange_gt: BigInt
  bptAmountChange_lt: BigInt
  bptAmountChange_gte: BigInt
  bptAmountChange_lte: BigInt
  bptAmountChange_in: [BigInt!]
  bptAmountChange_not_in: [BigInt!]
  sender: Bytes
  sender_not: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  receiver: Bytes
  receiver_not: Bytes
  receiver_in: [Bytes!]
  receiver_not_in: [Bytes!]
  receiver_contains: Bytes
  receiver_not_contains: Bytes
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input StakedNoteCoolDown_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  startedBlockHash: Bytes
  startedBlockHash_not: Bytes
  startedBlockHash_in: [Bytes!]
  startedBlockHash_not_in: [Bytes!]
  startedBlockHash_contains: Bytes
  startedBlockHash_not_contains: Bytes
  startedBlockNumber: Int
  startedBlockNumber_not: Int
  startedBlockNumber_gt: Int
  startedBlockNumber_lt: Int
  startedBlockNumber_gte: Int
  startedBlockNumber_lte: Int
  startedBlockNumber_in: [Int!]
  startedBlockNumber_not_in: [Int!]
  startedTimestamp: Int
  startedTimestamp_not: Int
  startedTimestamp_gt: Int
  startedTimestamp_lt: Int
  startedTimestamp_gte: Int
  startedTimestamp_lte: Int
  startedTimestamp_in: [Int!]
  startedTimestamp_not_in: [Int!]
  startedTransactionHash: Bytes
  startedTransactionHash_not: Bytes
  startedTransactionHash_in: [Bytes!]
  startedTransactionHash_not_in: [Bytes!]
  startedTransactionHash_contains: Bytes
  startedTransactionHash_not_contains: Bytes
  endedBlockHash: Bytes
  endedBlockHash_not: Bytes
  endedBlockHash_in: [Bytes!]
  endedBlockHash_not_in: [Bytes!]
  endedBlockHash_contains: Bytes
  endedBlockHash_not_contains: Bytes
  endedBlockNumber: Int
  endedBlockNumber_not: Int
  endedBlockNumber_gt: Int
  endedBlockNumber_lt: Int
  endedBlockNumber_gte: Int
  endedBlockNumber_lte: Int
  endedBlockNumber_in: [Int!]
  endedBlockNumber_not_in: [Int!]
  endedTimestamp: Int
  endedTimestamp_not: Int
  endedTimestamp_gt: Int
  endedTimestamp_lt: Int
  endedTimestamp_gte: Int
  endedTimestamp_lte: Int
  endedTimestamp_in: [Int!]
  endedTimestamp_not_in: [Int!]
  endedTransactionHash: Bytes
  endedTransactionHash_not: Bytes
  endedTransactionHash_in: [Bytes!]
  endedTransactionHash_not_in: [Bytes!]
  endedTransactionHash_contains: Bytes
  endedTransactionHash_not_contains: Bytes
  stakedNoteBalance: String
  stakedNoteBalance_not: String
  stakedNoteBalance_gt: String
  stakedNoteBalance_lt: String
  stakedNoteBalance_gte: String
  stakedNoteBalance_lte: String
  stakedNoteBalance_in: [String!]
  stakedNoteBalance_not_in: [String!]
  stakedNoteBalance_contains: String
  stakedNoteBalance_contains_nocase: String
  stakedNoteBalance_not_contains: String
  stakedNoteBalance_not_contains_nocase: String
  stakedNoteBalance_starts_with: String
  stakedNoteBalance_starts_with_nocase: String
  stakedNoteBalance_not_starts_with: String
  stakedNoteBalance_not_starts_with_nocase: String
  stakedNoteBalance_ends_with: String
  stakedNoteBalance_ends_with_nocase: String
  stakedNoteBalance_not_ends_with: String
  stakedNoteBalance_not_ends_with_nocase: String
  stakedNoteBalance_: StakedNoteBalance_filter
  userEndedCoolDown: Boolean
  userEndedCoolDown_not: Boolean
  userEndedCoolDown_in: [Boolean!]
  userEndedCoolDown_not_in: [Boolean!]
  redeemWindowBegin: Int
  redeemWindowBegin_not: Int
  redeemWindowBegin_gt: Int
  redeemWindowBegin_lt: Int
  redeemWindowBegin_gte: Int
  redeemWindowBegin_lte: Int
  redeemWindowBegin_in: [Int!]
  redeemWindowBegin_not_in: [Int!]
  redeemWindowEnd: Int
  redeemWindowEnd_not: Int
  redeemWindowEnd_gt: Int
  redeemWindowEnd_lt: Int
  redeemWindowEnd_gte: Int
  redeemWindowEnd_lte: Int
  redeemWindowEnd_in: [Int!]
  redeemWindowEnd_not_in: [Int!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input StakedNoteInvestment_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  manager: String
  manager_not: String
  manager_gt: String
  manager_lt: String
  manager_gte: String
  manager_lte: String
  manager_in: [String!]
  manager_not_in: [String!]
  manager_contains: String
  manager_contains_nocase: String
  manager_not_contains: String
  manager_not_contains_nocase: String
  manager_starts_with: String
  manager_starts_with_nocase: String
  manager_not_starts_with: String
  manager_not_starts_with_nocase: String
  manager_ends_with: String
  manager_ends_with_nocase: String
  manager_not_ends_with: String
  manager_not_ends_with_nocase: String
  manager_: TreasuryManager_filter
  bptPerSNOTEBefore: BigInt
  bptPerSNOTEBefore_not: BigInt
  bptPerSNOTEBefore_gt: BigInt
  bptPerSNOTEBefore_lt: BigInt
  bptPerSNOTEBefore_gte: BigInt
  bptPerSNOTEBefore_lte: BigInt
  bptPerSNOTEBefore_in: [BigInt!]
  bptPerSNOTEBefore_not_in: [BigInt!]
  bptPerSNOTEAfter: BigInt
  bptPerSNOTEAfter_not: BigInt
  bptPerSNOTEAfter_gt: BigInt
  bptPerSNOTEAfter_lt: BigInt
  bptPerSNOTEAfter_gte: BigInt
  bptPerSNOTEAfter_lte: BigInt
  bptPerSNOTEAfter_in: [BigInt!]
  bptPerSNOTEAfter_not_in: [BigInt!]
  totalETHInvested: BigInt
  totalETHInvested_not: BigInt
  totalETHInvested_gt: BigInt
  totalETHInvested_lt: BigInt
  totalETHInvested_gte: BigInt
  totalETHInvested_lte: BigInt
  totalETHInvested_in: [BigInt!]
  totalETHInvested_not_in: [BigInt!]
  totalNOTEInvested: BigInt
  totalNOTEInvested_not: BigInt
  totalNOTEInvested_gt: BigInt
  totalNOTEInvested_lt: BigInt
  totalNOTEInvested_gte: BigInt
  totalNOTEInvested_lte: BigInt
  totalNOTEInvested_in: [BigInt!]
  totalNOTEInvested_not_in: [BigInt!]
  totalSNOTESupply: BigInt
  totalSNOTESupply_not: BigInt
  totalSNOTESupply_gt: BigInt
  totalSNOTESupply_lt: BigInt
  totalSNOTESupply_gte: BigInt
  totalSNOTESupply_lte: BigInt
  totalSNOTESupply_in: [BigInt!]
  totalSNOTESupply_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input StakedNotePool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  totalBPTTokens: BigInt
  totalBPTTokens_not: BigInt
  totalBPTTokens_gt: BigInt
  totalBPTTokens_lt: BigInt
  totalBPTTokens_gte: BigInt
  totalBPTTokens_lte: BigInt
  totalBPTTokens_in: [BigInt!]
  totalBPTTokens_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  bptPerSNOTE: BigInt
  bptPerSNOTE_not: BigInt
  bptPerSNOTE_gt: BigInt
  bptPerSNOTE_lt: BigInt
  bptPerSNOTE_gte: BigInt
  bptPerSNOTE_lte: BigInt
  bptPerSNOTE_in: [BigInt!]
  bptPerSNOTE_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input StakedNoteTvl_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  sNOTETotalSupply: BigInt
  sNOTETotalSupply_not: BigInt
  sNOTETotalSupply_gt: BigInt
  sNOTETotalSupply_lt: BigInt
  sNOTETotalSupply_gte: BigInt
  sNOTETotalSupply_lte: BigInt
  sNOTETotalSupply_in: [BigInt!]
  sNOTETotalSupply_not_in: [BigInt!]
  poolNOTEBalance: BigInt
  poolNOTEBalance_not: BigInt
  poolNOTEBalance_gt: BigInt
  poolNOTEBalance_lt: BigInt
  poolNOTEBalance_gte: BigInt
  poolNOTEBalance_lte: BigInt
  poolNOTEBalance_in: [BigInt!]
  poolNOTEBalance_not_in: [BigInt!]
  poolETHBalance: BigInt
  poolETHBalance_not: BigInt
  poolETHBalance_gt: BigInt
  poolETHBalance_lt: BigInt
  poolETHBalance_gte: BigInt
  poolETHBalance_lte: BigInt
  poolETHBalance_in: [BigInt!]
  poolETHBalance_not_in: [BigInt!]
  poolBPTBalance: BigInt
  poolBPTBalance_not: BigInt
  poolBPTBalance_gt: BigInt
  poolBPTBalance_lt: BigInt
  poolBPTBalance_gte: BigInt
  poolBPTBalance_lte: BigInt
  poolBPTBalance_in: [BigInt!]
  poolBPTBalance_not_in: [BigInt!]
  spotPrice: BigInt
  spotPrice_not: BigInt
  spotPrice_gt: BigInt
  spotPrice_lt: BigInt
  spotPrice_gte: BigInt
  spotPrice_lte: BigInt
  spotPrice_in: [BigInt!]
  spotPrice_not_in: [BigInt!]
  totalPoolValueInNOTE: BigInt
  totalPoolValueInNOTE_not: BigInt
  totalPoolValueInNOTE_gt: BigInt
  totalPoolValueInNOTE_lt: BigInt
  totalPoolValueInNOTE_gte: BigInt
  totalPoolValueInNOTE_lte: BigInt
  totalPoolValueInNOTE_in: [BigInt!]
  totalPoolValueInNOTE_not_in: [BigInt!]
  totalPoolValueInETH: BigInt
  totalPoolValueInETH_not: BigInt
  totalPoolValueInETH_gt: BigInt
  totalPoolValueInETH_lt: BigInt
  totalPoolValueInETH_gte: BigInt
  totalPoolValueInETH_lte: BigInt
  totalPoolValueInETH_in: [BigInt!]
  totalPoolValueInETH_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Trade_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter
  tradeType: TradeType
  tradeType_not: TradeType
  tradeType_in: [TradeType!]
  tradeType_not_in: [TradeType!]
  maturity: BigInt
  maturity_not: BigInt
  maturity_gt: BigInt
  maturity_lt: BigInt
  maturity_gte: BigInt
  maturity_lte: BigInt
  maturity_in: [BigInt!]
  maturity_not_in: [BigInt!]
  netAssetCash: BigInt
  netAssetCash_not: BigInt
  netAssetCash_gt: BigInt
  netAssetCash_lt: BigInt
  netAssetCash_gte: BigInt
  netAssetCash_lte: BigInt
  netAssetCash_in: [BigInt!]
  netAssetCash_not_in: [BigInt!]
  netUnderlyingCash: BigInt
  netUnderlyingCash_not: BigInt
  netUnderlyingCash_gt: BigInt
  netUnderlyingCash_lt: BigInt
  netUnderlyingCash_gte: BigInt
  netUnderlyingCash_lte: BigInt
  netUnderlyingCash_in: [BigInt!]
  netUnderlyingCash_not_in: [BigInt!]
  netfCash: BigInt
  netfCash_not: BigInt
  netfCash_gt: BigInt
  netfCash_lt: BigInt
  netfCash_gte: BigInt
  netfCash_lte: BigInt
  netfCash_in: [BigInt!]
  netfCash_not_in: [BigInt!]
  netLiquidityTokens: BigInt
  netLiquidityTokens_not: BigInt
  netLiquidityTokens_gt: BigInt
  netLiquidityTokens_lt: BigInt
  netLiquidityTokens_gte: BigInt
  netLiquidityTokens_lte: BigInt
  netLiquidityTokens_in: [BigInt!]
  netLiquidityTokens_not_in: [BigInt!]
  transferOperator: Bytes
  transferOperator_not: Bytes
  transferOperator_in: [Bytes!]
  transferOperator_not_in: [Bytes!]
  transferOperator_contains: Bytes
  transferOperator_not_contains: Bytes
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input TreasuryManagerTradingLimit_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  treasury: String
  treasury_not: String
  treasury_gt: String
  treasury_lt: String
  treasury_gte: String
  treasury_lte: String
  treasury_in: [String!]
  treasury_not_in: [String!]
  treasury_contains: String
  treasury_contains_nocase: String
  treasury_not_contains: String
  treasury_not_contains_nocase: String
  treasury_starts_with: String
  treasury_starts_with_nocase: String
  treasury_not_starts_with: String
  treasury_not_starts_with_nocase: String
  treasury_ends_with: String
  treasury_ends_with_nocase: String
  treasury_not_ends_with: String
  treasury_not_ends_with_nocase: String
  treasury_: Treasury_filter
  tokenAddress: Bytes
  tokenAddress_not: Bytes
  tokenAddress_in: [Bytes!]
  tokenAddress_not_in: [Bytes!]
  tokenAddress_contains: Bytes
  tokenAddress_not_contains: Bytes
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  oracle: Bytes
  oracle_not: Bytes
  oracle_in: [Bytes!]
  oracle_not_in: [Bytes!]
  oracle_contains: Bytes
  oracle_not_contains: Bytes
  slippageLimit: BigInt
  slippageLimit_not: BigInt
  slippageLimit_gt: BigInt
  slippageLimit_lt: BigInt
  slippageLimit_gte: BigInt
  slippageLimit_lte: BigInt
  slippageLimit_in: [BigInt!]
  slippageLimit_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input TreasuryManager_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  startedBlockHash: Bytes
  startedBlockHash_not: Bytes
  startedBlockHash_in: [Bytes!]
  startedBlockHash_not_in: [Bytes!]
  startedBlockHash_contains: Bytes
  startedBlockHash_not_contains: Bytes
  startedBlockNumber: Int
  startedBlockNumber_not: Int
  startedBlockNumber_gt: Int
  startedBlockNumber_lt: Int
  startedBlockNumber_gte: Int
  startedBlockNumber_lte: Int
  startedBlockNumber_in: [Int!]
  startedBlockNumber_not_in: [Int!]
  startedTimestamp: Int
  startedTimestamp_not: Int
  startedTimestamp_gt: Int
  startedTimestamp_lt: Int
  startedTimestamp_gte: Int
  startedTimestamp_lte: Int
  startedTimestamp_in: [Int!]
  startedTimestamp_not_in: [Int!]
  startedTransactionHash: Bytes
  startedTransactionHash_not: Bytes
  startedTransactionHash_in: [Bytes!]
  startedTransactionHash_not_in: [Bytes!]
  startedTransactionHash_contains: Bytes
  startedTransactionHash_not_contains: Bytes
  endedBlockHash: Bytes
  endedBlockHash_not: Bytes
  endedBlockHash_in: [Bytes!]
  endedBlockHash_not_in: [Bytes!]
  endedBlockHash_contains: Bytes
  endedBlockHash_not_contains: Bytes
  endedBlockNumber: Int
  endedBlockNumber_not: Int
  endedBlockNumber_gt: Int
  endedBlockNumber_lt: Int
  endedBlockNumber_gte: Int
  endedBlockNumber_lte: Int
  endedBlockNumber_in: [Int!]
  endedBlockNumber_not_in: [Int!]
  endedTimestamp: Int
  endedTimestamp_not: Int
  endedTimestamp_gt: Int
  endedTimestamp_lt: Int
  endedTimestamp_gte: Int
  endedTimestamp_lte: Int
  endedTimestamp_in: [Int!]
  endedTimestamp_not_in: [Int!]
  endedTransactionHash: Bytes
  endedTransactionHash_not: Bytes
  endedTransactionHash_in: [Bytes!]
  endedTransactionHash_not_in: [Bytes!]
  endedTransactionHash_contains: Bytes
  endedTransactionHash_not_contains: Bytes
  isActiveManager: Boolean
  isActiveManager_not: Boolean
  isActiveManager_in: [Boolean!]
  isActiveManager_not_in: [Boolean!]
  treasury: String
  treasury_not: String
  treasury_gt: String
  treasury_lt: String
  treasury_gte: String
  treasury_lte: String
  treasury_in: [String!]
  treasury_not_in: [String!]
  treasury_contains: String
  treasury_contains_nocase: String
  treasury_not_contains: String
  treasury_not_contains_nocase: String
  treasury_starts_with: String
  treasury_starts_with_nocase: String
  treasury_not_starts_with: String
  treasury_not_starts_with_nocase: String
  treasury_ends_with: String
  treasury_ends_with_nocase: String
  treasury_not_ends_with: String
  treasury_not_ends_with_nocase: String
  treasury_: Treasury_filter
  sNOTEInvestments_: StakedNoteInvestment_filter
  tokenTrades_: TreasuryTokenTrade_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input TreasuryTokenTrade_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  manager: String
  manager_not: String
  manager_gt: String
  manager_lt: String
  manager_gte: String
  manager_lte: String
  manager_in: [String!]
  manager_not_in: [String!]
  manager_contains: String
  manager_contains_nocase: String
  manager_not_contains: String
  manager_not_contains_nocase: String
  manager_starts_with: String
  manager_starts_with_nocase: String
  manager_not_starts_with: String
  manager_not_starts_with_nocase: String
  manager_ends_with: String
  manager_ends_with_nocase: String
  manager_not_ends_with: String
  manager_not_ends_with_nocase: String
  manager_: TreasuryManager_filter
  takerAddress: Bytes
  takerAddress_not: Bytes
  takerAddress_in: [Bytes!]
  takerAddress_not_in: [Bytes!]
  takerAddress_contains: Bytes
  takerAddress_not_contains: Bytes
  makerAsset: String
  makerAsset_not: String
  makerAsset_gt: String
  makerAsset_lt: String
  makerAsset_gte: String
  makerAsset_lte: String
  makerAsset_in: [String!]
  makerAsset_not_in: [String!]
  makerAsset_contains: String
  makerAsset_contains_nocase: String
  makerAsset_not_contains: String
  makerAsset_not_contains_nocase: String
  makerAsset_starts_with: String
  makerAsset_starts_with_nocase: String
  makerAsset_not_starts_with: String
  makerAsset_not_starts_with_nocase: String
  makerAsset_ends_with: String
  makerAsset_ends_with_nocase: String
  makerAsset_not_ends_with: String
  makerAsset_not_ends_with_nocase: String
  makerAsset_: TreasuryManagerTradingLimit_filter
  takerAsset: Bytes
  takerAsset_not: Bytes
  takerAsset_in: [Bytes!]
  takerAsset_not_in: [Bytes!]
  takerAsset_contains: Bytes
  takerAsset_not_contains: Bytes
  takerAssetSymbol: String
  takerAssetSymbol_not: String
  takerAssetSymbol_gt: String
  takerAssetSymbol_lt: String
  takerAssetSymbol_gte: String
  takerAssetSymbol_lte: String
  takerAssetSymbol_in: [String!]
  takerAssetSymbol_not_in: [String!]
  takerAssetSymbol_contains: String
  takerAssetSymbol_contains_nocase: String
  takerAssetSymbol_not_contains: String
  takerAssetSymbol_not_contains_nocase: String
  takerAssetSymbol_starts_with: String
  takerAssetSymbol_starts_with_nocase: String
  takerAssetSymbol_not_starts_with: String
  takerAssetSymbol_not_starts_with_nocase: String
  takerAssetSymbol_ends_with: String
  takerAssetSymbol_ends_with_nocase: String
  takerAssetSymbol_not_ends_with: String
  takerAssetSymbol_not_ends_with_nocase: String
  takerAssetName: String
  takerAssetName_not: String
  takerAssetName_gt: String
  takerAssetName_lt: String
  takerAssetName_gte: String
  takerAssetName_lte: String
  takerAssetName_in: [String!]
  takerAssetName_not_in: [String!]
  takerAssetName_contains: String
  takerAssetName_contains_nocase: String
  takerAssetName_not_contains: String
  takerAssetName_not_contains_nocase: String
  takerAssetName_starts_with: String
  takerAssetName_starts_with_nocase: String
  takerAssetName_not_starts_with: String
  takerAssetName_not_starts_with_nocase: String
  takerAssetName_ends_with: String
  takerAssetName_ends_with_nocase: String
  takerAssetName_not_ends_with: String
  takerAssetName_not_ends_with_nocase: String
  takerAssetDecimals: Int
  takerAssetDecimals_not: Int
  takerAssetDecimals_gt: Int
  takerAssetDecimals_lt: Int
  takerAssetDecimals_gte: Int
  takerAssetDecimals_lte: Int
  takerAssetDecimals_in: [Int!]
  takerAssetDecimals_not_in: [Int!]
  makerAssetFilledAmount: BigInt
  makerAssetFilledAmount_not: BigInt
  makerAssetFilledAmount_gt: BigInt
  makerAssetFilledAmount_lt: BigInt
  makerAssetFilledAmount_gte: BigInt
  makerAssetFilledAmount_lte: BigInt
  makerAssetFilledAmount_in: [BigInt!]
  makerAssetFilledAmount_not_in: [BigInt!]
  takerAssetFilledAmount: BigInt
  takerAssetFilledAmount_not: BigInt
  takerAssetFilledAmount_gt: BigInt
  takerAssetFilledAmount_lt: BigInt
  takerAssetFilledAmount_gte: BigInt
  takerAssetFilledAmount_lte: BigInt
  takerAssetFilledAmount_in: [BigInt!]
  takerAssetFilledAmount_not_in: [BigInt!]
  oraclePrice: BigInt
  oraclePrice_not: BigInt
  oraclePrice_gt: BigInt
  oraclePrice_lt: BigInt
  oraclePrice_gte: BigInt
  oraclePrice_lte: BigInt
  oraclePrice_in: [BigInt!]
  oraclePrice_not_in: [BigInt!]
  oracleDecimals: Int
  oracleDecimals_not: Int
  oracleDecimals_gt: Int
  oracleDecimals_lt: Int
  oracleDecimals_gte: Int
  oracleDecimals_lte: Int
  oracleDecimals_in: [Int!]
  oracleDecimals_not_in: [Int!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Treasury_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  contractAddress: Bytes
  contractAddress_not: Bytes
  contractAddress_in: [Bytes!]
  contractAddress_not_in: [Bytes!]
  contractAddress_contains: Bytes
  contractAddress_not_contains: Bytes
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  activeManager: String
  activeManager_not: String
  activeManager_gt: String
  activeManager_lt: String
  activeManager_gte: String
  activeManager_lte: String
  activeManager_in: [String!]
  activeManager_not_in: [String!]
  activeManager_contains: String
  activeManager_contains_nocase: String
  activeManager_not_contains: String
  activeManager_not_contains_nocase: String
  activeManager_starts_with: String
  activeManager_starts_with_nocase: String
  activeManager_not_starts_with: String
  activeManager_not_starts_with_nocase: String
  activeManager_ends_with: String
  activeManager_ends_with_nocase: String
  activeManager_not_ends_with: String
  activeManager_not_ends_with_nocase: String
  activeManager_: TreasuryManager_filter
  investmentCoolDownInSeconds: BigInt
  investmentCoolDownInSeconds_not: BigInt
  investmentCoolDownInSeconds_gt: BigInt
  investmentCoolDownInSeconds_lt: BigInt
  investmentCoolDownInSeconds_gte: BigInt
  investmentCoolDownInSeconds_lte: BigInt
  investmentCoolDownInSeconds_in: [BigInt!]
  investmentCoolDownInSeconds_not_in: [BigInt!]
  NOTEPurchaseLimit: BigInt
  NOTEPurchaseLimit_not: BigInt
  NOTEPurchaseLimit_gt: BigInt
  NOTEPurchaseLimit_lt: BigInt
  NOTEPurchaseLimit_gte: BigInt
  NOTEPurchaseLimit_lte: BigInt
  NOTEPurchaseLimit_in: [BigInt!]
  NOTEPurchaseLimit_not_in: [BigInt!]
  tradingLimits_: TreasuryManagerTradingLimit_filter
  managers_: TreasuryManager_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input TvlHistoricalData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  usdTotal: BigInt
  usdTotal_not: BigInt
  usdTotal_gt: BigInt
  usdTotal_lt: BigInt
  usdTotal_gte: BigInt
  usdTotal_lte: BigInt
  usdTotal_in: [BigInt!]
  usdTotal_not_in: [BigInt!]
  perCurrencyTvl: [String!]
  perCurrencyTvl_not: [String!]
  perCurrencyTvl_contains: [String!]
  perCurrencyTvl_contains_nocase: [String!]
  perCurrencyTvl_not_contains: [String!]
  perCurrencyTvl_not_contains_nocase: [String!]
  perCurrencyTvl_: CurrencyTvl_filter
  compBalance: String
  compBalance_not: String
  compBalance_gt: String
  compBalance_lt: String
  compBalance_gte: String
  compBalance_lte: String
  compBalance_in: [String!]
  compBalance_not_in: [String!]
  compBalance_contains: String
  compBalance_contains_nocase: String
  compBalance_not_contains: String
  compBalance_not_contains_nocase: String
  compBalance_starts_with: String
  compBalance_starts_with_nocase: String
  compBalance_not_starts_with: String
  compBalance_not_starts_with_nocase: String
  compBalance_ends_with: String
  compBalance_ends_with_nocase: String
  compBalance_not_ends_with: String
  compBalance_not_ends_with_nocase: String
  compBalance_: COMPBalance_filter
  sNOTETvl: String
  sNOTETvl_not: String
  sNOTETvl_gt: String
  sNOTETvl_lt: String
  sNOTETvl_gte: String
  sNOTETvl_lte: String
  sNOTETvl_in: [String!]
  sNOTETvl_not_in: [String!]
  sNOTETvl_contains: String
  sNOTETvl_contains_nocase: String
  sNOTETvl_not_contains: String
  sNOTETvl_not_contains_nocase: String
  sNOTETvl_starts_with: String
  sNOTETvl_starts_with_nocase: String
  sNOTETvl_not_starts_with: String
  sNOTETvl_not_starts_with_nocase: String
  sNOTETvl_ends_with: String
  sNOTETvl_ends_with_nocase: String
  sNOTETvl_not_ends_with: String
  sNOTETvl_not_ends_with_nocase: String
  sNOTETvl_: StakedNoteTvl_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input Vote_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  proposal: String
  proposal_not: String
  proposal_gt: String
  proposal_lt: String
  proposal_gte: String
  proposal_lte: String
  proposal_in: [String!]
  proposal_not_in: [String!]
  proposal_contains: String
  proposal_contains_nocase: String
  proposal_not_contains: String
  proposal_not_contains_nocase: String
  proposal_starts_with: String
  proposal_starts_with_nocase: String
  proposal_not_starts_with: String
  proposal_not_starts_with_nocase: String
  proposal_ends_with: String
  proposal_ends_with_nocase: String
  proposal_not_ends_with: String
  proposal_not_ends_with_nocase: String
  proposal_: Proposal_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Delegate_filter
  yesToProposal: Boolean
  yesToProposal_not: Boolean
  yesToProposal_in: [Boolean!]
  yesToProposal_not_in: [Boolean!]
  votingPower: BigInt
  votingPower_not: BigInt
  votingPower_gt: BigInt
  votingPower_lt: BigInt
  votingPower_gte: BigInt
  votingPower_lte: BigInt
  votingPower_in: [BigInt!]
  votingPower_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input VotingPowerChange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  source: VotingPowerSource
  source_not: VotingPowerSource
  source_in: [VotingPowerSource!]
  source_not_in: [VotingPowerSource!]
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Delegate_filter
  votingPowerBefore: BigInt
  votingPowerBefore_not: BigInt
  votingPowerBefore_gt: BigInt
  votingPowerBefore_lt: BigInt
  votingPowerBefore_gte: BigInt
  votingPowerBefore_lte: BigInt
  votingPowerBefore_in: [BigInt!]
  votingPowerBefore_not_in: [BigInt!]
  votingPowerAfter: BigInt
  votingPowerAfter_not: BigInt
  votingPowerAfter_gt: BigInt
  votingPowerAfter_lt: BigInt
  votingPowerAfter_gte: BigInt
  votingPowerAfter_lte: BigInt
  votingPowerAfter_in: [BigInt!]
  votingPowerAfter_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input nTokenChange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockHash: Bytes
  blockHash_not: Bytes
  blockHash_in: [Bytes!]
  blockHash_not_in: [Bytes!]
  blockHash_contains: Bytes
  blockHash_not_contains: Bytes
  blockNumber: Int
  blockNumber_not: Int
  blockNumber_gt: Int
  blockNumber_lt: Int
  blockNumber_gte: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  blockNumber_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  transactionOrigin: Bytes
  transactionOrigin_not: Bytes
  transactionOrigin_in: [Bytes!]
  transactionOrigin_not_in: [Bytes!]
  transactionOrigin_contains: Bytes
  transactionOrigin_not_contains: Bytes
  nToken: String
  nToken_not: String
  nToken_gt: String
  nToken_lt: String
  nToken_gte: String
  nToken_lte: String
  nToken_in: [String!]
  nToken_not_in: [String!]
  nToken_contains: String
  nToken_contains_nocase: String
  nToken_not_contains: String
  nToken_not_contains_nocase: String
  nToken_starts_with: String
  nToken_starts_with_nocase: String
  nToken_not_starts_with: String
  nToken_not_starts_with_nocase: String
  nToken_ends_with: String
  nToken_ends_with_nocase: String
  nToken_not_ends_with: String
  nToken_not_ends_with_nocase: String
  nToken_: nToken_filter
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  assetChanges: [String!]
  assetChanges_not: [String!]
  assetChanges_contains: [String!]
  assetChanges_contains_nocase: [String!]
  assetChanges_not_contains: [String!]
  assetChanges_not_contains_nocase: [String!]
  assetChanges_: AssetChange_filter
  balanceChange: String
  balanceChange_not: String
  balanceChange_gt: String
  balanceChange_lt: String
  balanceChange_gte: String
  balanceChange_lte: String
  balanceChange_in: [String!]
  balanceChange_not_in: [String!]
  balanceChange_contains: String
  balanceChange_contains_nocase: String
  balanceChange_not_contains: String
  balanceChange_not_contains_nocase: String
  balanceChange_starts_with: String
  balanceChange_starts_with_nocase: String
  balanceChange_not_starts_with: String
  balanceChange_not_starts_with_nocase: String
  balanceChange_ends_with: String
  balanceChange_ends_with_nocase: String
  balanceChange_not_ends_with: String
  balanceChange_not_ends_with_nocase: String
  balanceChange_: BalanceChange_filter
  totalSupplyBefore: BigInt
  totalSupplyBefore_not: BigInt
  totalSupplyBefore_gt: BigInt
  totalSupplyBefore_lt: BigInt
  totalSupplyBefore_gte: BigInt
  totalSupplyBefore_lte: BigInt
  totalSupplyBefore_in: [BigInt!]
  totalSupplyBefore_not_in: [BigInt!]
  totalSupplyAfter: BigInt
  totalSupplyAfter_not: BigInt
  totalSupplyAfter_gt: BigInt
  totalSupplyAfter_lt: BigInt
  totalSupplyAfter_gte: BigInt
  totalSupplyAfter_lte: BigInt
  totalSupplyAfter_in: [BigInt!]
  totalSupplyAfter_not_in: [BigInt!]
  integralTotalSupplyBefore: BigInt
  integralTotalSupplyBefore_not: BigInt
  integralTotalSupplyBefore_gt: BigInt
  integralTotalSupplyBefore_lt: BigInt
  integralTotalSupplyBefore_gte: BigInt
  integralTotalSupplyBefore_lte: BigInt
  integralTotalSupplyBefore_in: [BigInt!]
  integralTotalSupplyBefore_not_in: [BigInt!]
  integralTotalSupplyAfter: BigInt
  integralTotalSupplyAfter_not: BigInt
  integralTotalSupplyAfter_gt: BigInt
  integralTotalSupplyAfter_lt: BigInt
  integralTotalSupplyAfter_gte: BigInt
  integralTotalSupplyAfter_lte: BigInt
  integralTotalSupplyAfter_in: [BigInt!]
  integralTotalSupplyAfter_not_in: [BigInt!]
  lastSupplyChangeTimeBefore: BigInt
  lastSupplyChangeTimeBefore_not: BigInt
  lastSupplyChangeTimeBefore_gt: BigInt
  lastSupplyChangeTimeBefore_lt: BigInt
  lastSupplyChangeTimeBefore_gte: BigInt
  lastSupplyChangeTimeBefore_lte: BigInt
  lastSupplyChangeTimeBefore_in: [BigInt!]
  lastSupplyChangeTimeBefore_not_in: [BigInt!]
  lastSupplyChangeTimeAfter: BigInt
  lastSupplyChangeTimeAfter_not: BigInt
  lastSupplyChangeTimeAfter_gt: BigInt
  lastSupplyChangeTimeAfter_lt: BigInt
  lastSupplyChangeTimeAfter_gte: BigInt
  lastSupplyChangeTimeAfter_lte: BigInt
  lastSupplyChangeTimeAfter_in: [BigInt!]
  lastSupplyChangeTimeAfter_not_in: [BigInt!]
  accumulatedNOTEPerNTokenBefore: BigInt
  accumulatedNOTEPerNTokenBefore_not: BigInt
  accumulatedNOTEPerNTokenBefore_gt: BigInt
  accumulatedNOTEPerNTokenBefore_lt: BigInt
  accumulatedNOTEPerNTokenBefore_gte: BigInt
  accumulatedNOTEPerNTokenBefore_lte: BigInt
  accumulatedNOTEPerNTokenBefore_in: [BigInt!]
  accumulatedNOTEPerNTokenBefore_not_in: [BigInt!]
  accumulatedNOTEPerNTokenAfter: BigInt
  accumulatedNOTEPerNTokenAfter_not: BigInt
  accumulatedNOTEPerNTokenAfter_gt: BigInt
  accumulatedNOTEPerNTokenAfter_lt: BigInt
  accumulatedNOTEPerNTokenAfter_gte: BigInt
  accumulatedNOTEPerNTokenAfter_lte: BigInt
  accumulatedNOTEPerNTokenAfter_in: [BigInt!]
  accumulatedNOTEPerNTokenAfter_not_in: [BigInt!]
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
input nToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lastUpdateBlockHash: Bytes
  lastUpdateBlockHash_not: Bytes
  lastUpdateBlockHash_in: [Bytes!]
  lastUpdateBlockHash_not_in: [Bytes!]
  lastUpdateBlockHash_contains: Bytes
  lastUpdateBlockHash_not_contains: Bytes
  lastUpdateBlockNumber: Int
  lastUpdateBlockNumber_not: Int
  lastUpdateBlockNumber_gt: Int
  lastUpdateBlockNumber_lt: Int
  lastUpdateBlockNumber_gte: Int
  lastUpdateBlockNumber_lte: Int
  lastUpdateBlockNumber_in: [Int!]
  lastUpdateBlockNumber_not_in: [Int!]
  lastUpdateTimestamp: Int
  lastUpdateTimestamp_not: Int
  lastUpdateTimestamp_gt: Int
  lastUpdateTimestamp_lt: Int
  lastUpdateTimestamp_gte: Int
  lastUpdateTimestamp_lte: Int
  lastUpdateTimestamp_in: [Int!]
  lastUpdateTimestamp_not_in: [Int!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_not_in: [Bytes!]
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  tokenAddress: Bytes
  tokenAddress_not: Bytes
  tokenAddress_in: [Bytes!]
  tokenAddress_not_in: [Bytes!]
  tokenAddress_contains: Bytes
  tokenAddress_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  integralTotalSupply: BigInt
  integralTotalSupply_not: BigInt
  integralTotalSupply_gt: BigInt
  integralTotalSupply_lt: BigInt
  integralTotalSupply_gte: BigInt
  integralTotalSupply_lte: BigInt
  integralTotalSupply_in: [BigInt!]
  integralTotalSupply_not_in: [BigInt!]
  accumulatedNOTEPerNToken: BigInt
  accumulatedNOTEPerNToken_not: BigInt
  accumulatedNOTEPerNToken_gt: BigInt
  accumulatedNOTEPerNToken_lt: BigInt
  accumulatedNOTEPerNToken_gte: BigInt
  accumulatedNOTEPerNToken_lte: BigInt
  accumulatedNOTEPerNToken_in: [BigInt!]
  accumulatedNOTEPerNToken_not_in: [BigInt!]
  lastSupplyChangeTime: BigInt
  lastSupplyChangeTime_not: BigInt
  lastSupplyChangeTime_gt: BigInt
  lastSupplyChangeTime_lt: BigInt
  lastSupplyChangeTime_gte: BigInt
  lastSupplyChangeTime_lte: BigInt
  lastSupplyChangeTime_in: [BigInt!]
  lastSupplyChangeTime_not_in: [BigInt!]
  cashGroup: String
  cashGroup_not: String
  cashGroup_gt: String
  cashGroup_lt: String
  cashGroup_gte: String
  cashGroup_lte: String
  cashGroup_in: [String!]
  cashGroup_not_in: [String!]
  cashGroup_contains: String
  cashGroup_contains_nocase: String
  cashGroup_not_contains: String
  cashGroup_not_contains_nocase: String
  cashGroup_starts_with: String
  cashGroup_starts_with_nocase: String
  cashGroup_not_starts_with: String
  cashGroup_not_starts_with_nocase: String
  cashGroup_ends_with: String
  cashGroup_ends_with_nocase: String
  cashGroup_not_ends_with: String
  cashGroup_not_ends_with_nocase: String
  cashGroup_: CashGroup_filter
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  depositShares: [Int!]
  depositShares_not: [Int!]
  depositShares_contains: [Int!]
  depositShares_contains_nocase: [Int!]
  depositShares_not_contains: [Int!]
  depositShares_not_contains_nocase: [Int!]
  leverageThresholds: [Int!]
  leverageThresholds_not: [Int!]
  leverageThresholds_contains: [Int!]
  leverageThresholds_contains_nocase: [Int!]
  leverageThresholds_not_contains: [Int!]
  leverageThresholds_not_contains_nocase: [Int!]
  annualizedAnchorRates: [Int!]
  annualizedAnchorRates_not: [Int!]
  annualizedAnchorRates_contains: [Int!]
  annualizedAnchorRates_contains_nocase: [Int!]
  annualizedAnchorRates_not_contains: [Int!]
  annualizedAnchorRates_not_contains_nocase: [Int!]
  proportions: [Int!]
  proportions_not: [Int!]
  proportions_contains: [Int!]
  proportions_contains_nocase: [Int!]
  proportions_not_contains: [Int!]
  proportions_not_contains_nocase: [Int!]
  incentiveEmissionRate: BigInt
  incentiveEmissionRate_not: BigInt
  incentiveEmissionRate_gt: BigInt
  incentiveEmissionRate_lt: BigInt
  incentiveEmissionRate_gte: BigInt
  incentiveEmissionRate_lte: BigInt
  incentiveEmissionRate_in: [BigInt!]
  incentiveEmissionRate_not_in: [BigInt!]
  residualPurchaseIncentiveBasisPoints: Int
  residualPurchaseIncentiveBasisPoints_not: Int
  residualPurchaseIncentiveBasisPoints_gt: Int
  residualPurchaseIncentiveBasisPoints_lt: Int
  residualPurchaseIncentiveBasisPoints_gte: Int
  residualPurchaseIncentiveBasisPoints_lte: Int
  residualPurchaseIncentiveBasisPoints_in: [Int!]
  residualPurchaseIncentiveBasisPoints_not_in: [Int!]
  residualPurchaseTimeBufferSeconds: Int
  residualPurchaseTimeBufferSeconds_not: Int
  residualPurchaseTimeBufferSeconds_gt: Int
  residualPurchaseTimeBufferSeconds_lt: Int
  residualPurchaseTimeBufferSeconds_gte: Int
  residualPurchaseTimeBufferSeconds_lte: Int
  residualPurchaseTimeBufferSeconds_in: [Int!]
  residualPurchaseTimeBufferSeconds_not_in: [Int!]
  cashWithholdingBufferBasisPoints: Int
  cashWithholdingBufferBasisPoints_not: Int
  cashWithholdingBufferBasisPoints_gt: Int
  cashWithholdingBufferBasisPoints_lt: Int
  cashWithholdingBufferBasisPoints_gte: Int
  cashWithholdingBufferBasisPoints_lte: Int
  cashWithholdingBufferBasisPoints_in: [Int!]
  cashWithholdingBufferBasisPoints_not_in: [Int!]
  pvHaircutPercentage: Int
  pvHaircutPercentage_not: Int
  pvHaircutPercentage_gt: Int
  pvHaircutPercentage_lt: Int
  pvHaircutPercentage_gte: Int
  pvHaircutPercentage_lte: Int
  pvHaircutPercentage_in: [Int!]
  pvHaircutPercentage_not_in: [Int!]
  liquidationHaircutPercentage: Int
  liquidationHaircutPercentage_not: Int
  liquidationHaircutPercentage_gt: Int
  liquidationHaircutPercentage_lt: Int
  liquidationHaircutPercentage_gte: Int
  liquidationHaircutPercentage_lte: Int
  liquidationHaircutPercentage_in: [Int!]
  liquidationHaircutPercentage_not_in: [Int!]
  account_: Account_filter
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
}
"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT
"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT
"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION
